###### backend\config.py
from typing import Literal

from pydantic_settings import BaseSettings, SettingsConfigDict


class GlobalSettings(BaseSettings):
    MONGO_INITDB_ROOT_USERNAME: str
    MONGO_INITDB_ROOT_PASSWORD: str
    MONGO_INITDB_HOST: str
    ME_CONFIG_BASICAUTH: str  # for docker

    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    POSTGRES_PORT: str

    S3_USER: str
    S3_PASSWORD: str
    S3_PORT: str

    BACKEND_URL: str
    FRONTEND_URL: str

    model_config = SettingsConfigDict(
        env_file="../.env", env_file_encoding="utf-8", extra="ignore"
    )


class Settings(BaseSettings):
    DEV: bool
    TEST_MODE: bool

    DB_URL: str
    TEST_DB_URL: str

    INVITE_TOKEN_JWT: str
    SECRET_KEY_REFRESH: str

    COOKIE_HTTPONLY: bool
    COOKIE_SECURE: bool
    COOKIE_SAMESITE: Literal["lax", "strict", "none"]

    S3_BUCKET_NAME: str
    S3_PATH: str

    JWT_ACCESS_TOKEN_SECRET_KEY: str
    JWT_ALGORITHM: str
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8")


settings = Settings()  # type: ignore

global_setttigns = GlobalSettings()  # type: ignore

__all__ = ["settings", "global_setttigns"]


###### backend\config_logging.py
import logging

from colorama import Fore, Style, init


class ColoredFormatter(logging.Formatter):
    COLORS = {
        "DEBUG": Fore.BLUE,
        "INFO": Fore.GREEN,
        "WARNING": Fore.YELLOW,
        "ERROR": Fore.RED,
        "CRITICAL": Fore.RED + Style.BRIGHT,
    }

    def format(self, record):
        color = self.COLORS.get(record.levelname, Fore.WHITE)
        message = super().format(record)
        return f"{color}{message}{Style.RESET_ALL}"


def setup_logging():
    init(autoreset=True)

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    stream_handler = logging.StreamHandler()
    file_handler = logging.FileHandler("log.log", mode="a")

    formatter = ColoredFormatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")

    stream_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)

    logger.addHandler(stream_handler)
    logger.addHandler(file_handler)


###### backend\exceptions.py
from fastapi import FastAPI, status
from fastapi.responses import JSONResponse
from jwt import DecodeError, ExpiredSignatureError, InvalidTokenError

from src.utils.exeptions import PermissionGroupDeniedError


def exception_handler(app: FastAPI):
    @app.exception_handler(ExpiredSignatureError)
    async def jwt_expired_token_handler(request, exc):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content={"detail": "Token expired"},
        )

    @app.exception_handler(InvalidTokenError)
    async def jwt_invalid_token_handler(request, exc):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content={"detail": "Invalid token"},
        )

    @app.exception_handler(DecodeError)
    async def http_exception_handler(request, exc):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content={"detail": "Invalid token"},
        )

    @app.exception_handler(PermissionGroupDeniedError)
    async def permission_denied_handler(request, exc):
        return JSONResponse(
            status_code=status.HTTP_403_FORBIDDEN,
            content={"detail": "Permission denied"},
        )


###### backend\main.py
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from config import global_setttigns, settings
from config_logging import setup_logging
from exceptions import exception_handler
from src.core.nosql.database import init_mongo_db
from src.endpoints.auth.router import router as auth_router
from src.endpoints.chat.router import router as chat_router
from src.endpoints.group.router import router as group_router
from src.endpoints.message.router import router as message_router
from src.endpoints.role.router import router as role_router
from src.endpoints.user.router import router as user_router

# set settings and color for logging
setup_logging()
logging.getLogger("pymongo").setLevel(logging.INFO)
logging.getLogger("multipart").setLevel(logging.INFO)


@asynccontextmanager
async def lifespan(app: FastAPI):
    await init_mongo_db()
    yield


app = FastAPI(docs_url="/api/docs", openapi_url="/api/openapi.json", lifespan=lifespan)


origins = [global_setttigns.BACKEND_URL, global_setttigns.FRONTEND_URL]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# In message_router there is a websocket route
# /api/messages/{chat_id}?token=jwt
app.include_router(prefix="/api", router=auth_router)
app.include_router(prefix="/api", router=group_router)
app.include_router(prefix="/api", router=user_router)
app.include_router(prefix="/api", router=chat_router)
app.include_router(prefix="/api", router=role_router)
app.include_router(prefix="/api", router=message_router)

exception_handler(app)


@app.get("/api")
def ping():
    return "pong"


if __name__ == "__main__":
    assert not settings.TEST_MODE
    import uvicorn

    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
    )


###### backend\docs_tools\combine_code.py
import os


def combine_code_files(root_dir, output_file, excluded_dirs=None):
    """
    Объединяет код из всех файлов в папке и подпапках в один файл.
    Исключает указанные директории (по умолчанию 'venv').

    :param root_dir: Путь к корневой папке с кодом
    :param output_file: Файл для вывода результата
    :param excluded_dirs: Список исключаемых папок
    """
    if excluded_dirs is None:
        excluded_dirs = ["venv"]

    with open(output_file, "w", encoding="utf-8") as out_f:
        for root, dirs, files in os.walk(root_dir):
            # Исключаем указанные директории
            dirs[:] = [d for d in dirs if d not in excluded_dirs]

            for file in files:
                if not file.endswith(
                    (".py", ".js", ".html", ".scss", ".tsx", ".jsx", "ts")
                ):  # Ваши расширения
                    continue
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding="utf-8") as in_f:
                        content = in_f.read()

                    # Записываем заголовок файла
                    relative_path = os.path.relpath(file_path, root_dir)
                    out_f.write(f"###### {relative_path}\n")
                    out_f.write(content)
                    out_f.write("\n\n")  # Добавляем отступ между файлами

                except (UnicodeDecodeError, PermissionError) as e:
                    print(f"Пропущен файл {file_path} ({str(e)})")


if __name__ == "__main__":
    # Настройки
    SOURCE_DIR = (
        r"C:\home\project\margeletV2"  # Текущая папка (можно указать любой путь)
    )
    OUTPUT_FILE = "combined_code.txt"
    EXCLUDED_DIRS = [
        ".venv",
        ".git",
        "__pycache__",
        "backend.egg-info",
        "node_modules",
        ".next",
        "api_auto",
    ]  # Папки для исключения

    print(f"Объединение файлов из {SOURCE_DIR}...")
    combine_code_files(SOURCE_DIR, OUTPUT_FILE, EXCLUDED_DIRS)
    print(f"Готово! Результат сохранён в {OUTPUT_FILE}")


###### backend\docs_tools\diagram.py
r"""
Paste this in console if you want install it on windows
uv pip install --config-settings="--global-option=build_ext" --config-settings="
--global-option=-IC:\Program Files\Graphviz\include" --config-settings="
--global-option=-LC:\Program Files\Graphviz\lib" pygraphviz
uv pip install erdantic
uv pip install eralchemy
Taken from
https://pygraphviz.github.io/documentation/stable/install.html
"""

import os
import pathlib
import sys
from pathlib import Path

from dotenv import load_dotenv

# Загружаем .env из корня проекта
load_dotenv(dotenv_path=pathlib.Path(__file__).resolve().parent.parent / ".env")

sys.path.insert(0, str(Path(__file__).parent.parent))

if sys.platform == "win32":
    path = pathlib.Path(r"C:\Program Files\Graphviz\bin")
    if path.is_dir() and str(path) not in os.environ["PATH"]:
        os.environ["PATH"] += f";{path}"

import erdantic as erd
from eralchemy import render_er

from src.core.db.database import Base
from src.core.db.models import *  # noqa: F403

## Draw from SQLAlchemy base
render_er(Base, "postgres_diagram.png")


from src.core.nosql.models import IdToUsernameModel, MessageModel

erd.draw(MessageModel, IdToUsernameModel, out="schema_mongo_db.png")


###### backend\src\__init__.py


###### backend\src\core\__init__.py


###### backend\src\core\abstract\dao_base.py
from typing import Any, Generic, Protocol, cast, get_args
from uuid import UUID

from beanie import Document
from sqlalchemy import delete, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.db.database import Base
from src.utils.exeptions import ModelNotFoundException
from src.utils.types import (
    CreateSchemaType,
    ModelType,
    ReadSchemaType,
    UpdateSchemaType,
)


class DaoProtocol(
    Protocol[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType]
):
    """Abstract class for Dao"""

    async def get_one_by_id(self, id: UUID) -> ReadSchemaType: ...

    async def get_one_by_field(self, *filter) -> ReadSchemaType:
        """You should pass filter as Model.id == id"""
        ...

    async def get_many_by_field(self, *filter) -> list[ReadSchemaType]:
        """You should pass filter as Model.id == id"""
        ...

    async def get_all(self) -> list[ReadSchemaType]: ...

    async def create(self, obj: CreateSchemaType) -> ReadSchemaType: ...

    async def update(self, obj: UpdateSchemaType) -> ReadSchemaType:
        """Pass id in values, You should pass filter as Model.id == id"""
        ...

    async def delete(self, id: UUID) -> bool: ...


class Dao(Generic[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType]):
    """Use for dao logic, also used for dao service"""

    model_type: Any
    read_schema_type: type[ReadSchemaType]

    def __init_subclass__(cls) -> None:
        # used in sublass of DAO
        # __init_subclass__ is called when subclass is initialized
        # __orig_bases__ return all class inheritance
        # if we not pass type in generic we will get error
        if not hasattr(cls, "__orig_bases__"):
            raise ValueError("Repository must be implements")
        # get first generic class (SqlDaoImpl[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType])
        base_dao_generic, *_ = cls.__orig_bases__  # type: ignore
        # we garant that types in generic are correct
        cls.model_type, cls.read_schema_type, *_ = cast(
            tuple[
                type[ModelType],
                type[ReadSchemaType],
                type[CreateSchemaType],
                type[UpdateSchemaType],
            ],
            get_args(base_dao_generic),
        )
        return super().__init_subclass__()


class SqlDaoImpl(Dao[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType]):
    """Sql implementation of Dao with default crud methods"""

    model_type: type[Base]

    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_one_by_id(self, id: UUID) -> ReadSchemaType:
        result = await self.session.execute(
            select(self.model_type).filter(self.model_type.id == id)
        )

        record = result.scalar_one_or_none()

        if record is None:
            raise ModelNotFoundException(self.model_type.__name__, id)

        return self.read_schema_type.model_validate(record)

    async def get_one_by_field(self, *filter) -> ReadSchemaType:
        result = await self.session.execute(select(self.model_type).filter(*filter))

        record = result.scalar_one_or_none()

        if record is None:
            raise ModelNotFoundException(self.model_type.__name__, id)

        return self.read_schema_type.model_validate(result.scalar_one())

    async def get_many_by_field(self, *filter) -> list[ReadSchemaType]:
        result = await self.session.execute(select(self.model_type).filter(*filter))
        return [self.read_schema_type.model_validate(i) for i in result.scalars().all()]

    async def get_all(self) -> list[ReadSchemaType]:
        result = await self.session.execute(select(self.model_type))
        return [self.read_schema_type.model_validate(i) for i in result.scalars().all()]

    async def create(self, obj: CreateSchemaType) -> ReadSchemaType:
        obj_model = self.model_type(**obj.model_dump())
        self.session.add(obj_model)
        await self.session.commit()
        await self.session.refresh(obj_model)
        return self.read_schema_type.model_validate(obj_model)

    async def update(self, obj: UpdateSchemaType) -> ReadSchemaType:
        result = await self.session.execute(
            update(self.model_type)
            .filter(self.model_type.id == id)
            .values(obj.model_dump(exclude={"id"}, exclude_unset=True))
            .returning(self.model_type),
        )
        await self.session.commit()
        return self.read_schema_type.model_validate(result.scalar_one())

    async def delete(self, id: UUID) -> bool:
        await self.session.execute(
            delete(self.model_type).filter(self.model_type.id == id)
        )  # type: ignore
        await self.session.commit()
        return True


class MongoDaoImpl(Dao[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType]):
    """Mongo implementation of Dao with default crud methods"""

    model_type: type[Document]

    async def get_one_by_id(self, id: UUID) -> ReadSchemaType:
        result = await self.model_type.get(id, fetch_links=True)

        if result is None:
            raise ModelNotFoundException(self.model_type.__name__, id)

        return self.read_schema_type.model_validate(result)

    async def get_one_by_field(self, *filter) -> ReadSchemaType:
        result = await self.model_type.find_one(*filter, fetch_links=True)

        if result is None:
            raise ModelNotFoundException(self.model_type.__name__, id)

        return self.read_schema_type.model_validate(result)

    async def get_many_by_field(self, *filter) -> list[ReadSchemaType]:
        result = await self.model_type.find(*filter, fetch_links=True).to_list()
        return [self.read_schema_type.model_validate(i) for i in result]

    async def get_all(self) -> list[ReadSchemaType]:
        result = await self.model_type.find(fetch_links=True).to_list()
        return [self.read_schema_type.model_validate(i) for i in result]

    async def create(self, obj: CreateSchemaType) -> ReadSchemaType:
        obj_model = self.model_type(**obj.model_dump())
        result = await obj_model.insert()
        return self.read_schema_type.model_validate(result)

    async def update(self, obj: UpdateSchemaType) -> ReadSchemaType:
        obj_model = await self.model_type.find_one(obj.id == id)

        if obj_model is None:
            raise ModelNotFoundException(self.model_type.__name__, id)

        result = await obj_model.update(
            obj.model_dump(exclude={"id"}, exclude_unset=True)
        )

        return self.read_schema_type.model_validate(result)

    async def delete(self, id: UUID) -> bool:
        result = await self.model_type.get(id)

        if result is None:
            raise ModelNotFoundException(self.model_type.__name__, id)

        await result.delete()

        return True


###### backend\src\core\abstract\permission_base.py
from typing import Any
from uuid import UUID

from src.utils.exeptions import NotFoundModelException, PermissionNotHasAttributeError


class Permission:
    """
    Class for check a conditions in router,
    raise exeptions, which handled in exception handler
    """

    def is_has_value(self, obj: Any, field: str) -> None:
        """Is required field in object has any data"""
        assert hasattr(self, obj)

        result = getattr(self, field)

        if result is not None:
            raise PermissionNotHasAttributeError()

        return result


class PermissionService(Permission):
    """
    Abstract class for check permission
    Using class for service layer
    """

    def __init__(self, service):
        self.service = service

    async def check_exist_by_id(self, id: UUID, model: Any) -> None:
        """use for check is exist object, return object for optimization"""
        assert hasattr(model, "id")

        result = await self.service.get_one_by_id(id)

        if result is None:
            raise NotFoundModelException()

        return result

    async def is_has_value_model(self, id: Any, field: str) -> None:
        """checks if the model instance contains a field"""
        db_result = await self.service.get_one_by_id(id)

        assert hasattr(db_result, field)

        result = getattr(db_result, field)

        if result is not None:
            raise PermissionNotHasAttributeError()

        return result


###### backend\src\core\abstract\service_base.py
from typing import Any
from uuid import UUID

from src.core.abstract.dao_base import Dao, DaoProtocol
from src.utils.types import (
    CreateSchemaType,
    ModelType,
    ReadSchemaType,
    UpdateSchemaType,
)


class BaseService:
    """
    Root class for all Service class
    """

    pass


class DaoServiceProtocol(
    DaoProtocol[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType]
):
    pass


class DaoService(
    Dao[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType], BaseService
):
    """Abstract class founded dao methods with permission,
    T - return type"""

    def __init__(
        self,
        dao: DaoProtocol[ModelType, ReadSchemaType, CreateSchemaType, UpdateSchemaType],
    ):
        self.dao = dao

    async def get_one_by_id(self, id: UUID) -> ReadSchemaType:
        return await self.dao.get_one_by_id(id)

    async def get_one_by_field(self, *filter: Any) -> ReadSchemaType:
        return await self.dao.get_one_by_field(*filter)

    async def get_many_by_field(self, *filter: Any) -> list[ReadSchemaType]:
        return await self.dao.get_many_by_field(*filter)

    async def get_all(self) -> list[ReadSchemaType]:
        return await self.dao.get_all()

    async def create(self, obj: CreateSchemaType) -> ReadSchemaType:
        return await self.dao.create(obj)

    async def update(self, obj: UpdateSchemaType) -> ReadSchemaType:
        return await self.dao.update(obj)

    async def delete(self, obj: Any) -> bool:
        return await self.dao.delete(obj)


###### backend\src\core\abstract\storage_base.py
from abc import ABC, abstractmethod
from typing import Any

from fastapi import UploadFile


class StorageBase(ABC):
    @abstractmethod
    async def get(self, key: str) -> Any:
        """return not null file"""
        pass

    @abstractmethod
    async def save(self, key: str, value: Any) -> Any:
        """save file to storage"""
        pass

    @abstractmethod
    async def delete(self, key: str) -> Any:
        """delete file from storage"""
        pass

    @abstractmethod
    async def save_image(self, key: str, value: UploadFile) -> list[str]:
        """save object as image to storage"""
        pass


###### backend\src\core\db\database.py
from typing import Annotated, AsyncGenerator

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from sqlalchemy.orm import DeclarativeBase

from config import settings


class Base(DeclarativeBase):
    pass


if settings.TEST_MODE:
    from sqlalchemy.pool import NullPool

    engine = create_async_engine(settings.TEST_DB_URL, poolclass=NullPool)
else:
    engine = create_async_engine(settings.DB_URL)

async_session_maker = async_sessionmaker(engine, expire_on_commit=False)


async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        yield session


async_session = Annotated[AsyncSession, Depends(get_async_session)]


async def create_db_and_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


__all__ = ["get_async_session", "async_session", "create_db_and_tables", "Base"]


###### backend\src\core\db\__init__.py
from src.core.db.models.secondary_models.models import UserToGroupModel
from src.endpoints.auth.refresh_token.models import TokenModel
from src.endpoints.chat.models import ChatModel
from src.endpoints.group.models import GroupModel
from src.endpoints.role.models import RoleModel
from src.endpoints.role.user_role.models import UserToRoleModel
from src.endpoints.user.models import UserModel

__all__ = [
    "TokenModel",
    "UserModel",
    "ChatModel",
    "GroupModel",
    "UserToGroupModel",
    "RoleModel",
    "UserToRoleModel",
]


###### backend\src\core\db\alembic\env.py
import asyncio
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from config import settings
from src.core.db.database import Base
from src.core.db.models import *  # noqa: F403

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config
config.set_main_option("sqlalchemy.url", settings.DB_URL)
# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""

    asyncio.run(run_async_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


###### backend\src\core\db\alembic\versions\64f5ece52f0f_.py
"""empty message

Revision ID: 64f5ece52f0f
Revises: e0b525ab09b1
Create Date: 2025-06-01 22:37:41.365641

"""

from typing import Sequence, Union

# revision identifiers, used by Alembic.
revision: str = "64f5ece52f0f"
down_revision: Union[str, None] = "e0b525ab09b1"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


###### backend\src\core\db\alembic\versions\e0b525ab09b1_.py
"""empty message

Revision ID: e0b525ab09b1
Revises:
Create Date: 2025-05-29 12:18:43.290443

"""

from typing import Sequence, Union

import fastapi_users_db_sqlalchemy
import sqlalchemy as sa
from alembic import op
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "e0b525ab09b1"
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "group",
        sa.Column("id", sa.UUID(), nullable=False),
        sa.Column("title", sa.String(length=20), nullable=False),
        sa.Column("description", sa.String(), nullable=False),
        sa.Column("avatar_path", sa.String(), nullable=True),
        sa.Column("panorama_path", sa.String(), nullable=True),
        sa.Column("is_group_one_chat", sa.Boolean(), nullable=False),
        sa.Column("is_personal_group", sa.Boolean(), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("title"),
    )
    op.create_table(
        "user",
        sa.Column("id", sa.UUID(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("account_name", sa.String(), nullable=False),
        sa.Column("email", sa.String(), nullable=False),
        sa.Column("avatar_path", sa.String(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("hashed_password", sa.String(length=1024), nullable=False),
        sa.Column("is_active", sa.Boolean(), nullable=False),
        sa.Column("is_superuser", sa.Boolean(), nullable=False),
        sa.Column("is_verified", sa.Boolean(), nullable=False),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("account_name"),
        sa.UniqueConstraint("email"),
    )
    op.create_table(
        "chat",
        sa.Column("id", sa.UUID(), nullable=False),
        sa.Column("title", sa.String(), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("group_id", sa.UUID(), nullable=False),
        sa.ForeignKeyConstraint(
            ["group_id"],
            ["group.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "refresh_token",
        sa.Column(
            "user_id", fastapi_users_db_sqlalchemy.generics.GUID(), nullable=False
        ),
        sa.Column("token", sa.String(length=43), nullable=False),
        sa.Column(
            "created_at",
            fastapi_users_db_sqlalchemy.generics.TIMESTAMPAware(timezone=True),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["user_id"], ["user.id"], ondelete="cascade"),
        sa.PrimaryKeyConstraint("token"),
    )
    op.create_index(
        op.f("ix_refresh_token_created_at"),
        "refresh_token",
        ["created_at"],
        unique=False,
    )
    op.create_table(
        "role",
        sa.Column("id", sa.UUID(), nullable=False),
        sa.Column("title", sa.String(), nullable=False),
        sa.Column(
            "permissions",
            postgresql.ARRAY(
                postgresql.ENUM(
                    "CAN_ALL",
                    "CAN_EDIT_ROLES",
                    "CAN_SET_AVATAR",
                    "CAN_SET_PANORAMA",
                    "CAN_CONTROL_CHATS",
                    "CAN_SEND_MESSAGE",
                    "CAN_INVITE",
                    name="role_permissions",
                )
            ),
            nullable=False,
        ),
        sa.Column("group_id", sa.UUID(), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.ForeignKeyConstraint(
            ["group_id"],
            ["group.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "user_to_group",
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.UUID(), nullable=True),
        sa.Column("group_id", sa.UUID(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(
            ["group_id"],
            ["group.id"],
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["user.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "user_to_role",
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.UUID(), nullable=False),
        sa.Column("role_id", sa.UUID(), nullable=False),
        sa.ForeignKeyConstraint(
            ["role_id"],
            ["role.id"],
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["user.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("user_to_role")
    op.drop_table("user_to_group")
    op.drop_table("role")
    op.drop_index(op.f("ix_refresh_token_created_at"), table_name="refresh_token")
    op.drop_table("refresh_token")
    op.drop_table("chat")
    op.drop_table("user")
    op.drop_table("group")
    # ### end Alembic commands ###


###### backend\src\core\db\models\__init__.py
# from src.endpoints.chat.models import ChatModel
# from src.endpoints.group.models import GroupModel
# from src.endpoints.auth.refresh_token.models import TokenModel
# from src.endpoints.role.models import RoleModel
# from src.endpoints.role.user_role.models import UserToRoleModel
# from src.endpoints.user.models import UserModel

# from .secondary_models.models import UserToGroupModel

# __all__ = [
#     "TokenModel",
#     "UserModel",
#     "ChatModel",
#     "GroupModel",
#     "UserToGroupModel",
#     "RoleModel",
#     "UserToRoleModel",
# ]


###### backend\src\core\db\models\secondary_models\models.py
from datetime import datetime, timezone

from sqlalchemy import Column, DateTime, ForeignKey, Integer, Table
from sqlalchemy.dialects.postgresql import UUID

from src.core.db.database import Base

UserToGroupModel = Table(
    "user_to_group",
    Base.metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("user_id", UUID, ForeignKey("user.id")),
    Column("group_id", UUID, ForeignKey("group.id")),
    Column(
        "created_at",
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
    ),
)


###### backend\src\core\db\models\secondary_models\__init__.py


###### backend\src\core\nosql\database.py
from beanie import init_beanie
from motor.motor_asyncio import AsyncIOMotorClient

from config import global_setttigns

from .models import IdToUsernameModel, MessageModel

client = AsyncIOMotorClient(
    f"mongodb://{global_setttigns.MONGO_INITDB_ROOT_USERNAME}:{global_setttigns.MONGO_INITDB_ROOT_PASSWORD}@{global_setttigns.MONGO_INITDB_HOST}:27017/"
)


async def init_mongo_db():
    await init_beanie(
        database=client.margelet, document_models=[MessageModel, IdToUsernameModel]
    )


###### backend\src\core\nosql\models\__init__.py
from src.endpoints.message.id_to_username.models import IdToUsernameModel
from src.endpoints.message.models import MessageModel

__all__ = ["MessageModel", "IdToUsernameModel"]


###### backend\src\endpoints\__init__.py


###### backend\src\endpoints\auth\depends.py
from typing import Annotated

from fastapi import Depends

from config import settings
from src.endpoints.auth.schemas import AccessTokenJWTSchema
from src.endpoints.auth.service import get_user_from_access
from src.endpoints.auth.users import fastapi_users_current_user
from src.endpoints.user.depends import user_dao_factory
from src.endpoints.user.models import UserModel
from src.utils.depends import oauth2_scheme
from src.utils.jwt import JWTManager

access_token = Annotated[str, Depends(oauth2_scheme)]


def get_jwt_manager_access() -> JWTManager[AccessTokenJWTSchema]:
    return JWTManager(
        settings.JWT_ACCESS_TOKEN_SECRET_KEY,
        AccessTokenJWTSchema,
        settings.JWT_ALGORITHM,
        settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES,
    )


jwt_manager_access = Annotated[
    JWTManager[AccessTokenJWTSchema], Depends(get_jwt_manager_access)
]


async def get_current_user_from_access(
    access_token: access_token, jwt: jwt_manager_access, dao: user_dao_factory
):
    return await get_user_from_access(access_token, jwt, dao)


current_user = Annotated[UserModel, Depends(get_current_user_from_access)]

current_user_from_refresh = Annotated[UserModel, Depends(fastapi_users_current_user)]


__all__ = ["current_user_from_refresh", "current_user", "get_current_user_from_access"]


###### backend\src\endpoints\auth\router.py
from fastapi.routing import APIRouter

from src.endpoints.auth.depends import current_user, current_user_from_refresh
from src.endpoints.auth.schemas import AccessTokenJWTSchema

from .depends import jwt_manager_access
from .schemas import UserCreate, UserRead, UserUpdate
from .users import auth_backend, fastapi_users

router = APIRouter(prefix="")

router.include_router(
    fastapi_users.get_auth_router(auth_backend), prefix="/auth/jwt", tags=["auth"]
)
router.include_router(
    fastapi_users.get_register_router(UserRead, UserCreate),
    prefix="/auth",
    tags=["auth"],
)
router.include_router(
    fastapi_users.get_reset_password_router(),
    prefix="/auth",
    tags=["auth"],
)
router.include_router(
    fastapi_users.get_verify_router(UserRead),
    prefix="/auth",
    tags=["auth"],
)
router.include_router(
    fastapi_users.get_users_router(UserRead, UserUpdate),
    prefix="/users",
    tags=["users"],
)


@router.get("/auth/me", tags=["auth"])
async def authenticated_route(user: current_user_from_refresh):
    return {"message": f"Hello {user.email}!"}


@router.get("/auth/me_alterntive", tags=["auth"])
async def authenticated_route_alterntive(user: current_user):
    return {"message": f"Hello {user.email}!"}


@router.post("/auth/access_token", tags=["auth"])
async def get_access_token(
    jwt: jwt_manager_access,
    user: current_user_from_refresh,
):
    """
    Get and set in cookie access token using refresh token
    """
    token_data = AccessTokenJWTSchema(user_id=str(user.id))

    access_token = jwt.encode(token_data)
    return {"access_token": access_token}


###### backend\src\endpoints\auth\schemas.py
import uuid

from fastapi_users import schemas
from pydantic import BaseModel

from src.endpoints.user.schemas import (
    CreateUserSchema,
    ReadUserSchema,
    UpdateUserSchema,
)


class UserRead(schemas.BaseUser[uuid.UUID], ReadUserSchema):
    pass


class UserCreate(schemas.BaseUserCreate, CreateUserSchema):
    pass


class UserUpdate(schemas.BaseUserUpdate, UpdateUserSchema):
    pass


class AccessTokenJWTSchema(BaseModel):
    user_id: str  # UUID must be converted


###### backend\src\endpoints\auth\service.py
from uuid import UUID

from src.endpoints.user.dao import UserDaoProtocol
from src.utils.jwt import JWTManager

from .schemas import AccessTokenJWTSchema


async def get_user_from_access(
    access_token: str,
    jwt_manager_access: JWTManager[AccessTokenJWTSchema],
    UserDao: UserDaoProtocol,
):
    token_data = AccessTokenJWTSchema.model_validate(
        jwt_manager_access.decode(access_token)
    )
    return await UserDao.get_one_by_id(UUID(token_data.user_id))


###### backend\src\endpoints\auth\users.py
import uuid
from typing import Annotated, AsyncGenerator, Optional

from fastapi import Depends, Request
from fastapi_users import BaseUserManager, FastAPIUsers, UUIDIDMixin
from fastapi_users.authentication import AuthenticationBackend, CookieTransport
from fastapi_users.db import SQLAlchemyUserDatabase

from config import settings
from src.endpoints.auth.refresh_token.dao import get_database_strategy
from src.endpoints.user.depends import get_user_db
from src.endpoints.user.models import UserModel

SECRET = "SECRET"


class UserManager(UUIDIDMixin, BaseUserManager[UserModel, uuid.UUID]):
    reset_password_token_secret = SECRET
    verification_token_secret = SECRET

    async def on_after_register(
        self, user: UserModel, request: Optional[Request] = None
    ):
        print(f"User {user.id} has registered.")

    async def on_after_forgot_password(
        self, user: UserModel, token: str, request: Optional[Request] = None
    ):
        print(f"User {user.id} has forgot their password. Reset token: {token}")

    async def on_after_login(self, user, request, response):
        pass

    async def on_after_request_verify(
        self, user: UserModel, token: str, request: Optional[Request] = None
    ):
        print(f"Verification requested for user {user.id}. Verification token: {token}")


async def get_user_manager(
    user_db: Annotated[SQLAlchemyUserDatabase, Depends(get_user_db)],
) -> AsyncGenerator[UserManager, None]:
    yield UserManager(user_db)


cookie_transport = CookieTransport(
    cookie_name="refresh_token",
    cookie_max_age=60 * 60 * 24 * 24,
    cookie_httponly=settings.COOKIE_HTTPONLY,
    cookie_secure=settings.COOKIE_SECURE,
    cookie_samesite=settings.COOKIE_SAMESITE,
)


auth_backend = AuthenticationBackend(
    name="db_cookie",
    transport=cookie_transport,
    get_strategy=get_database_strategy,
)

fastapi_users = FastAPIUsers[UserModel, uuid.UUID](get_user_manager, [auth_backend])

fastapi_users_current_user = fastapi_users.current_user(active=True)


###### backend\src\endpoints\auth\__init__.py


###### backend\src\endpoints\auth\refresh_token\dao.py
from typing import Annotated, AsyncGenerator

from fastapi import Depends
from fastapi_users.authentication.strategy.db import (
    AccessTokenDatabase,
    DatabaseStrategy,
)
from fastapi_users_db_sqlalchemy.access_token import SQLAlchemyAccessTokenDatabase
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.db.database import get_async_session

from .models import TokenModel


async def get_refresh_token_db(
    session: Annotated[AsyncSession, Depends(get_async_session)],
) -> AsyncGenerator[SQLAlchemyAccessTokenDatabase, None]:
    """return dao for refresh token"""
    yield SQLAlchemyAccessTokenDatabase(session, TokenModel)


def get_database_strategy(
    access_token_db: Annotated[
        AccessTokenDatabase[TokenModel], Depends(get_refresh_token_db)
    ],
) -> DatabaseStrategy:
    return DatabaseStrategy(access_token_db, lifetime_seconds=60 * 60 * 24 * 24)


###### backend\src\endpoints\auth\refresh_token\depends.py


###### backend\src\endpoints\auth\refresh_token\models.py
from fastapi_users_db_sqlalchemy.access_token import SQLAlchemyBaseAccessTokenTableUUID

from src.core.db.database import Base


class TokenModel(SQLAlchemyBaseAccessTokenTableUUID, Base):
    __tablename__ = "refresh_token"


###### backend\src\endpoints\auth\refresh_token\schemas.py
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict


class BaseTokenSchema(BaseModel):
    id: UUID
    value: str
    user_id: UUID
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class ReadTokenSchema(BaseTokenSchema):
    pass


###### backend\src\endpoints\auth\refresh_token\__init__.py


###### backend\src\endpoints\chat\dao.py
from typing import Protocol
from uuid import UUID

from sqlalchemy import select

from src.core.abstract.dao_base import DaoProtocol, SqlDaoImpl
from src.core.db.models.secondary_models.models import UserToGroupModel
from src.endpoints.chat.models import ChatModel
from src.endpoints.chat.schemas import (
    CreateChatSchema,
    ReadChatSchema,
    UpdateChatSchema,
)
from src.endpoints.group.models import GroupModel


class ChatDaoProtocol(
    DaoProtocol[ChatModel, ReadChatSchema, CreateChatSchema, UpdateChatSchema],
    Protocol,
):
    async def get_chats_by_user(self, user_id: UUID) -> list[ReadChatSchema]: ...

    async def get_chats_by_group(self, group_id: UUID) -> list[ReadChatSchema]: ...


class ChatSqlDao(
    SqlDaoImpl[ChatModel, ReadChatSchema, CreateChatSchema, UpdateChatSchema],
):
    async def get_chats_by_user(self, user_id: UUID) -> list[ReadChatSchema]:
        result = await self.session.execute(
            select(ChatModel)
            .join(UserToGroupModel, UserToGroupModel.c.user_id == user_id)
            .join(GroupModel, GroupModel.id == UserToGroupModel.c.group_id)
            .filter(ChatModel.group_id == GroupModel.id)
        )
        return [ReadChatSchema.model_validate(i) for i in result.scalars().all()]

    async def get_chats_by_group(self, group_id: UUID) -> list[ReadChatSchema]:
        result = await self.session.execute(
            select(ChatModel).filter(ChatModel.group_id == group_id)
        )
        return [ReadChatSchema.model_validate(i) for i in result.scalars().all()]


###### backend\src\endpoints\chat\depends.py
from typing import Annotated

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.db.database import get_async_session
from src.infrastructure.s3 import s3_service_factory

from .dao import ChatSqlDao
from .service import ChatService


def get_chat_dao(session: Annotated[AsyncSession, Depends(get_async_session)]):
    return ChatSqlDao(session)


chat_dao_factory = Annotated[ChatSqlDao, Depends(get_chat_dao)]


def get_chat_service(
    dao: chat_dao_factory,
    storage: s3_service_factory,
) -> ChatService:
    return ChatService(dao, storage)


chat_service_factory = Annotated[ChatService, Depends(get_chat_service)]

__all__ = ["chat_dao_factory", "chat_service_factory"]


###### backend\src\endpoints\chat\models.py
from __future__ import annotations

import uuid
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from sqlalchemy import DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.db.database import Base

if TYPE_CHECKING:
    from src.endpoints.group.models import GroupModel


class ChatModel(Base):
    __tablename__ = "chat"

    id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    title: Mapped[str] = mapped_column()
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
    )

    group_id: Mapped[UUID] = mapped_column(ForeignKey("group.id"), nullable=False)
    group: Mapped["GroupModel"] = relationship(back_populates="chats")


###### backend\src\endpoints\chat\permissions.py
from typing import Annotated

from fastapi import Depends

from src.core.abstract.permission_base import PermissionService
from src.endpoints.chat.depends import chat_dao_factory


class ChatPermission(PermissionService):
    pass


def get_chat_permission(dao: chat_dao_factory):
    return ChatPermission(dao)


chat_permission = Annotated[ChatPermission, Depends(get_chat_permission)]


###### backend\src\endpoints\chat\router.py
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Body
from fastapi.responses import JSONResponse

from src.endpoints.auth.depends import current_user
from src.endpoints.group.permissions import group_permission
from src.endpoints.role.models import RolePermissionsEnum
from src.endpoints.role.permissions import role_permission

from .depends import chat_service_factory
from .schemas import CreateChatSchema, ReadChatSchema, UpdateChatSchema

router = APIRouter(prefix="/chats", tags=["chat"])


@router.get("/group_chats/{group_id}")
async def get_group_chats(
    group_id: UUID,
    chat_service: chat_service_factory,
    group_perm: group_permission,
    user: current_user,
) -> list[ReadChatSchema]:
    await group_perm.check_user_in_group(user.id, group_id)

    return [
        ReadChatSchema.model_validate(chat)
        for chat in await chat_service.get_chats_by_group(group_id)
    ]


@router.post("/{group_id}")
async def create_chat(
    group_id: UUID,
    chat: Annotated[CreateChatSchema, Body()],
    chat_service: chat_service_factory,
):
    return await chat_service.create(
        CreateChatSchema(group_id=group_id, **chat.model_dump(exclude_unset=True))
    )


@router.patch("/{chat_id}")
async def update_chat(
    chat_id: UUID,
    chat: Annotated[UpdateChatSchema, Body()],
    chat_service: chat_service_factory,
    role_perm: role_permission,
    user: current_user,
):
    chat_db = await chat_service.get_one_by_id(chat_id)

    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_CONTROL_CHATS, user.id, chat_db.group_id
    )
    await chat_service.update(UpdateChatSchema(id=chat_id, **chat.model_dump()))

    return JSONResponse(status_code=200, content={"message": "Chat updated"})


@router.delete("/{chat_id}")
async def delete_chat(
    chat_id: UUID,
    chat_service: chat_service_factory,
    role_perm: role_permission,
    user: current_user,
):
    chat_db = await chat_service.get_one_by_id(chat_id)

    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_CONTROL_CHATS, user.id, chat_db.group_id
    )
    await chat_service.delete(chat_id)

    return JSONResponse(status_code=200, content={"message": "Chat deleted"})


###### backend\src\endpoints\chat\schemas.py
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict


class BaseChatSchema(BaseModel):
    id: UUID
    title: str
    created_at: datetime
    group_id: UUID
    model_config = ConfigDict(from_attributes=True)


class ReadChatSchema(BaseChatSchema):
    pass


class CreateChatSchema(BaseModel):
    title: str
    group_id: UUID | None = None


class UpdateChatSchema(BaseModel):
    id: UUID
    title: str | None = None


###### backend\src\endpoints\chat\service.py
from typing import TYPE_CHECKING
from uuid import UUID

from src.core.abstract.service_base import DaoService
from src.core.abstract.storage_base import StorageBase
from src.endpoints.chat.models import ChatModel
from src.endpoints.chat.schemas import (
    CreateChatSchema,
    ReadChatSchema,
    UpdateChatSchema,
)

from .dao import ChatDaoProtocol


class ChatService(
    DaoService[ChatModel, ReadChatSchema, CreateChatSchema, UpdateChatSchema]
):
    def __init__(
        self,
        dao: ChatDaoProtocol,
        storage_service: StorageBase,
    ):
        self.storage_service = storage_service

        if TYPE_CHECKING:
            self.dao = dao

        super().__init__(dao)

    async def get_chats_by_user(self, user_id: UUID) -> list[ReadChatSchema]:
        return await self.dao.get_chats_by_user(user_id)

    async def get_chats_by_group(self, group_id: UUID) -> list[ReadChatSchema]:
        return await self.dao.get_chats_by_group(group_id)


###### backend\src\endpoints\chat\__init__.py


###### backend\src\endpoints\group\dao.py
from typing import Protocol, override
from uuid import UUID

from sqlalchemy import and_, insert, select

from src.core.abstract.dao_base import DaoProtocol, SqlDaoImpl
from src.core.db.models.secondary_models.models import UserToGroupModel
from src.endpoints.group.models import GroupModel
from src.endpoints.group.schemas import (
    CreateGroupSchema,
    ReadGroupSchema,
    UpdateGroupSchema,
)
from src.endpoints.role.user_role.models import UserToRoleModel


class GroupDaoProtocol(
    DaoProtocol[GroupModel, ReadGroupSchema, CreateGroupSchema, UpdateGroupSchema],
    Protocol,
):
    @override
    async def create(
        self, obj: CreateGroupSchema, user_id: UUID
    ) -> ReadGroupSchema: ...

    async def is_user_in_group(self, id: UUID, user_id: UUID) -> bool: ...

    async def add_user_to_group(self, id: UUID, user_id: UUID) -> bool: ...

    async def get_groups_by_user(self, user_id: UUID) -> list[ReadGroupSchema]: ...

    async def add_role_to_user(self, user_id: UUID, role_id: UUID) -> bool: ...


class GroupSqlDao(
    SqlDaoImpl[GroupModel, ReadGroupSchema, CreateGroupSchema, UpdateGroupSchema],
):
    @override
    async def create(self, obj: CreateGroupSchema, user_id: UUID) -> ReadGroupSchema:
        obj: GroupModel = GroupModel(**obj.model_dump())
        self.session.add(obj)
        await self.session.flush()
        await self.session.execute(
            insert(UserToGroupModel).values(group_id=obj.id, user_id=user_id)
        )
        await self.session.commit()
        await self.session.refresh(obj)
        return self.read_schema_type.model_validate(obj)

    async def is_user_in_group(self, id: UUID, user_id: UUID) -> bool:
        result = await self.session.execute(
            select(UserToGroupModel)
            .filter(UserToGroupModel.c.user_id == user_id)
            .filter(UserToGroupModel.c.group_id == id)
        )
        if result.scalar_one_or_none() is None:
            return False

        return True

    async def add_user_to_group(self, id: UUID, user_id: UUID) -> bool:
        await self.session.execute(
            insert(UserToGroupModel).values(group_id=id, user_id=user_id)
        )
        await self.session.commit()
        return True

    async def get_groups_by_user(self, user_id: UUID) -> list[ReadGroupSchema]:
        result = await self.session.execute(
            select(GroupModel).join(
                UserToGroupModel,
                and_(
                    UserToGroupModel.c.user_id == user_id,
                    UserToGroupModel.c.group_id == GroupModel.id,
                ),
            )
        )
        return [ReadGroupSchema.model_validate(i) for i in result.scalars().all()]

    async def add_role_to_user(self, user_id: UUID, role_id: UUID) -> bool:
        await self.session.execute(insert(UserToRoleModel).values(user_id, role_id))
        await self.session.commit()
        return True


###### backend\src\endpoints\group\depends.py
from typing import Annotated

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from config import settings
from src.core.db.database import get_async_session
from src.endpoints.group.schemas import InvitationTokenSchema
from src.infrastructure.s3 import s3_service_factory
from src.utils.jwt import JWTManager

from .dao import GroupSqlDao
from .service import GroupService


def get_jwt_manager_invitation() -> JWTManager[InvitationTokenSchema]:
    return JWTManager(
        settings.INVITE_TOKEN_JWT, InvitationTokenSchema, "HS256", 60 * 24
    )


jwt_manager_invitation = Annotated[
    JWTManager[InvitationTokenSchema], Depends(get_jwt_manager_invitation)
]


def get_group_dao(
    session: Annotated[AsyncSession, Depends(get_async_session)],
) -> GroupSqlDao:
    return GroupSqlDao(session)


group_dao_factory = Annotated[GroupSqlDao, Depends(get_group_dao)]


def get_group_service(
    dao: group_dao_factory,
    storage: s3_service_factory,
) -> GroupService:
    return GroupService(dao, storage)


group_service_factory = Annotated[GroupService, Depends(get_group_service)]

__all__ = ["group_dao_factory", "group_service_factory", "jwt_manager_invitation"]


###### backend\src\endpoints\group\models.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import TYPE_CHECKING
from uuid import uuid4

from sqlalchemy import DateTime, String
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.db.database import Base

if TYPE_CHECKING:
    from src.endpoints.chat.models import ChatModel
    from src.endpoints.role.models import RoleModel
    from src.endpoints.user.models import UserModel


class GroupModel(Base):
    __tablename__ = "group"

    id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    title: Mapped[str] = mapped_column(String(length=20), unique=True, nullable=False)
    description: Mapped[str] = mapped_column(nullable=False)
    avatar_path: Mapped[str] = mapped_column(nullable=True)
    panorama_path: Mapped[str] = mapped_column(nullable=True)
    is_group_one_chat: Mapped[bool] = mapped_column(default=True)
    is_personal_group: Mapped[bool] = mapped_column(default=False)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
    )

    users: Mapped[list["UserModel"]] = relationship(
        secondary="user_to_group", back_populates="groups"
    )

    chats: Mapped[list["ChatModel"]] = relationship(
        back_populates="group", lazy="selectin"
    )

    roles: Mapped[list["RoleModel"]] = relationship(
        back_populates="group", lazy="selectin"
    )


###### backend\src\endpoints\group\permissions.py
from typing import Annotated
from uuid import UUID

from fastapi import Depends

from src.core.abstract.permission_base import PermissionService
from src.endpoints.group.depends import group_service_factory
from src.endpoints.group.service import GroupService
from src.utils.exeptions import PermissionGroupDeniedError


class GroupPermission(PermissionService):
    def __init__(self, service: GroupService):
        self.service = service

    async def check_user_in_group(self, user_id: UUID, group_id: UUID) -> None:
        status = await self.service.is_user_in_group(user_id, group_id)

        if not status:
            raise PermissionGroupDeniedError()


def get_group_permission(group_service: group_service_factory):
    return GroupPermission(group_service)


group_permission = Annotated[GroupPermission, Depends(get_group_permission)]

__all__ = ["group_permission"]


###### backend\src\endpoints\group\router.py
import logging
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Body, UploadFile
from fastapi.responses import JSONResponse, Response

from src.endpoints.auth.depends import current_user
from src.endpoints.group.permissions import group_permission
from src.endpoints.role.depends import role_service_factory
from src.endpoints.role.models import (
    RoleModel,
    RolePermissionsEnum,
    creator_permissions,
    newbie_permissions,
)
from src.endpoints.role.permissions import role_permission
from src.endpoints.role.schemas import CreateRoleSchema
from src.endpoints.user.depends import user_service_factory

from .depends import group_service_factory, jwt_manager_invitation
from .models import GroupModel
from .schemas import (
    CreateGroupSchema,
    InvitationTokenSchema,
    ReadGroupSchema,
    UpdateGroupSchema,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/groups", tags=["group"])


@router.get("/avatar/{group_id}")
async def load_avatar(
    group_id: UUID,
    permission: group_permission,
    group_service: group_service_factory,
) -> Response:
    await permission.is_has_value_model(group_id, "avatar_path")

    response = await group_service.load_avatar(f"/groups/{group_id}_avatar.jpg")

    return Response(content=response, media_type="image/png")


@router.post("/avatar/{group_id}")
async def upload_avatar(
    group_id: UUID,
    image: UploadFile,
    permission: group_permission,
    group_service: group_service_factory,
    role_perm: role_permission,
    user: current_user,
):
    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_EDIT_GROUP_SETTINGS, user.id, group_id
    )

    await permission.check_exist_by_id(group_id, GroupModel)

    path = f"groups/{str(group_id)}_avatar.jpg"
    await group_service.upload_avatar(path, image)
    await group_service.update(UpdateGroupSchema(id=group_id, avatar_path=path))
    return JSONResponse(status_code=200, content={"message": "Avatar uploaded"})


@router.get("/panorama/{group_id}")
async def load_panorama(
    group_id: UUID,
    permission: group_permission,
    group_service: group_service_factory,
) -> Response:
    await permission.is_has_value_model(group_id, "avatar_path")

    response = await group_service.load_panorama(f"/groups/{group_id}_panorama.jpg")
    return Response(content=response, media_type="image/png")


@router.post("/panorama/{group_id}")
async def upload_panorama(
    group_id: UUID,
    image: UploadFile,
    group_service: group_service_factory,
    role_perm: role_permission,
    user: current_user,
):
    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_EDIT_GROUP_SETTINGS, user.id, group_id
    )

    path = f"groups/{str(group_id)}_panorama.jpg"
    await group_service.upload_panorama(path, image)
    await group_service.update(UpdateGroupSchema(id=group_id, panorama_path=path))
    return JSONResponse(status_code=200, content={"message": "Panorama uploaded"})


@router.get("/invite/{group_id}")
async def get_invite_token(
    group_id: UUID,
    user: current_user,
    group_perm: group_permission,
    jwt: jwt_manager_invitation,
    role_perm: role_permission,
):
    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_INVITE, user.id, group_id
    )

    await group_perm.check_exist_by_id(group_id, GroupModel)

    token = jwt.encode(
        InvitationTokenSchema.model_validate(
            {"group_id": str(group_id), "user_id": str(user.id)}
        )
    )
    return token


@router.post("/invite/{group_id}")
async def join_group(
    group_id: UUID,
    token: Annotated[str, Body()],
    user: current_user,
    user_service: user_service_factory,
    group_service: group_service_factory,
    role_service: role_service_factory,
    jwt: jwt_manager_invitation,
    role_perm: role_permission,
):
    payload = jwt.decode(token)
    user_payload_id = UUID(payload)
    group_payload_id = UUID(group_id)
    user_creator_token = await user_service.get_one_by_id(user_payload_id)

    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_INVITE, user_creator_token.id, group_id
    )

    await group_service.add_user_to_group(group_payload_id, user.id)
    newbie_role = await role_service.get_one_by_field(
        RoleModel.title == "newbie", RoleModel.group_id == group_id
    )
    await group_service.add_role_to_user(user.id, newbie_role.id)

    return JSONResponse(status_code=200, content={"message": "Group joined"})


@router.get("/user_groups/me")
async def get_my_groups(
    user: current_user, group_service: group_service_factory
) -> list[ReadGroupSchema]:
    return await group_service.get_groups_by_user(user.id)


@router.get(
    "/{group_id}",
)
async def get_group(
    group_id: UUID,
    group_service: group_service_factory,
) -> ReadGroupSchema:
    return await group_service.get_one_by_id(group_id)


@router.post("/")
async def create_group(
    group: Annotated[CreateGroupSchema, Body()],
    user: current_user,
    group_service: group_service_factory,
    role_service: role_service_factory,
) -> ReadGroupSchema:
    result = await group_service.create(group, user.id)
    # Create base user roles
    creator_role = await role_service.create(
        CreateRoleSchema(
            title="creator",
            group_id=result.id,
            permissions=creator_permissions,
        )
    )
    newbie_role = await role_service.create(
        CreateRoleSchema(
            title="newbie",
            group_id=result.id,
            permissions=newbie_permissions,
        )
    )
    await group_service.add_role_to_user(user.id, creator_role.id)
    await group_service.add_role_to_user(user.id, newbie_role.id)

    return result


@router.patch("/")
async def update_group(
    group: Annotated[UpdateGroupSchema, Body()],
    group_service: group_service_factory,
    user: current_user,
    role_perm: role_permission,
) -> ReadGroupSchema:
    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_EDIT_GROUP_SETTINGS, user.id, group.id
    )
    return await group_service.update(group)


@router.delete("/{group_id}")
async def delete_group(
    group_id: UUID,
    group_service: group_service_factory,
    user: current_user,
    role_perm: role_permission,
):
    await role_perm.check_user_has_permission(
        RolePermissionsEnum.CAN_ALL, user.id, group_id
    )

    await group_service.delete(group_id)

    return JSONResponse(status_code=200, content={"message": "Group deleted"})


###### backend\src\endpoints\group\schemas.py
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from src.endpoints.chat.schemas import BaseChatSchema
from src.endpoints.role.schemas import BaseRoleSchema


class BaseGroupSchema(BaseModel):
    id: UUID
    title: str = Field(max_length=20)
    description: str
    avatar_path: str | None = None
    panorama_path: str | None = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class ReadGroupSchema(BaseGroupSchema):
    # users shouldn't be included
    # users: list["ReadUserSchema"] = []
    chats: list["BaseChatSchema"] = []
    roles: list["BaseRoleSchema"] = []


class CreateGroupSchema(BaseModel):
    title: str
    description: str


class UpdateGroupSchema(BaseModel):
    id: UUID
    title: str | None = None
    description: str | None = None
    avatar_path: str | None = None
    panorama_path: str | None = None


class InvitationTokenSchema(BaseModel):
    user_id: str
    group_id: str


###### backend\src\endpoints\group\service.py
from uuid import UUID

from fastapi import UploadFile

from src.core.abstract.service_base import DaoService
from src.core.abstract.storage_base import StorageBase
from src.endpoints.group.models import GroupModel
from src.endpoints.group.schemas import (
    CreateGroupSchema,
    ReadGroupSchema,
    UpdateGroupSchema,
)

from .dao import GroupDaoProtocol


class GroupService(
    DaoService[GroupModel, ReadGroupSchema, CreateGroupSchema, UpdateGroupSchema]
):
    def __init__(
        self,
        dao: GroupDaoProtocol,
        storage_service: StorageBase,
    ):
        self.storage_service = storage_service
        self.dao = dao

    async def create(self, obj: CreateGroupSchema, user_id: UUID) -> ReadGroupSchema:
        return await self.dao.create(obj, user_id)

    async def load_avatar(self, key: str) -> bytes:
        return await self.storage_service.get(key)

    async def load_panorama(self, key: str) -> bytes:
        return await self.storage_service.get(key)

    async def upload_avatar(self, key: str, value: UploadFile) -> None:
        value_bytes = await value.read()
        return await self.storage_service.save(key, value_bytes)

    async def upload_panorama(self, key: str, value: UploadFile) -> None:
        value_bytes = await value.read()
        await self.storage_service.save(key, value_bytes)

    async def is_user_in_group(self, user_id: UUID, group_id: UUID) -> bool:
        return await self.dao.is_user_in_group(group_id, user_id)

    async def add_user_to_group(self, id: UUID, user_id: UUID) -> bool:
        return await self.dao.add_user_to_group(id, user_id)

    async def get_groups_by_user(self, user_id: UUID) -> list[ReadGroupSchema]:
        return await self.dao.get_groups_by_user(user_id)

    async def add_role_to_user(self, user_id: UUID, role_id: UUID) -> bool:
        return await self.dao.add_role_to_user(user_id, role_id)


###### backend\src\endpoints\group\__init__.py


###### backend\src\endpoints\message\dao.py
from typing import Protocol

from src.core.abstract.dao_base import DaoProtocol, MongoDaoImpl
from src.endpoints.message.schemas import (
    CreateMessageSchema,
    ReadMessageSchema,
    UpdateMessageSchema,
)

from .models import MessageModel


class MessageDaoProtocol(
    DaoProtocol[
        MessageModel, ReadMessageSchema, CreateMessageSchema, UpdateMessageSchema
    ],
    Protocol,
):
    pass


class MessageMongoDao(
    MongoDaoImpl[
        MessageModel, ReadMessageSchema, CreateMessageSchema, UpdateMessageSchema
    ]
):
    pass


###### backend\src\endpoints\message\depends.py
from typing import Annotated

from fastapi import Depends

from src.infrastructure.s3 import s3_service_factory

from .dao import MessageMongoDao
from .service import MessageService


def get_message_dao():
    return MessageMongoDao()


message_dao_factory = Annotated[MessageMongoDao, Depends(get_message_dao)]


def get_message_service(
    dao: message_dao_factory,
    storage: s3_service_factory,
) -> MessageService:
    return MessageService(dao, storage)


message_service_factory = Annotated[MessageService, Depends(get_message_service)]

__all__ = [
    "message_dao_factory",
    "message_service_factory",
]


###### backend\src\endpoints\message\models.py
from datetime import datetime, timezone
from uuid import UUID, uuid4

from beanie import Document
from pydantic import Field


class MessageModel(Document):
    id: UUID = Field(default_factory=uuid4)
    id_in_chat: int = Field(default=0)
    message: str
    user_id: UUID
    to_chat_id: UUID
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    class Settings:
        name = "message"


###### backend\src\endpoints\message\permissions.py
from typing import Annotated

from fastapi import Depends

from src.core.abstract.permission_base import PermissionService
from src.endpoints.message.depends import message_dao_factory


class MessagePermission(PermissionService):
    pass


def get_message_permission(dao: message_dao_factory):
    return MessagePermission(dao)


message_permission = Annotated[MessagePermission, Depends(get_message_permission)]

__all__ = ["message_permission"]


###### backend\src\endpoints\message\router.py
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Query, WebSocket, WebSocketDisconnect, WebSocketException

from src.endpoints.auth.depends import (
    current_user,
    get_current_user_from_access,
    jwt_manager_access,
)
from src.endpoints.chat.depends import chat_service_factory
from src.endpoints.group.permissions import group_permission
from src.endpoints.message.id_to_username.depends import id_to_username_dao
from src.endpoints.message.id_to_username.schemas import CreateIdToUsernameModelSchema
from src.endpoints.user.depends import user_dao_factory
from src.endpoints.user.schemas import ReadUserSchema
from src.utils.exeptions import ModelNotFoundException

from .depends import message_service_factory
from .models import MessageModel
from .schemas import CreateMessageSchema, ReadMessageSchema

router = APIRouter(prefix="/messages", tags=["messages"])


@router.get("/chat/{chat_id}")
async def get_all_messages_chat(
    user: current_user,
    chat_id: UUID,
    message_service: message_service_factory,
    chat_service: chat_service_factory,
    id_user_dao: id_to_username_dao,
    group_perm: group_permission,
) -> list[ReadMessageSchema]:
    chat_db = await chat_service.get_one_by_id(chat_id)

    await group_perm.check_user_in_group(user.id, chat_db.group_id)

    raw_messages = await message_service.get_many_by_field(
        MessageModel.to_chat_id == chat_id
    )

    messages: list[ReadMessageSchema] = []
    for message in raw_messages:
        message = ReadMessageSchema.model_validate(message)

        try:
            username_db = await id_user_dao.get_one_by_id(message.user_id)
        except ModelNotFoundException:
            username_db = await id_user_dao.create(
                CreateIdToUsernameModelSchema(id=message.user_id, username=user.name)
            )

        message.author = username_db.username
        messages.append(message)

    return messages


class ConnectionManager:
    def __init__(self):
        self.active_connections: dict[UUID, list[WebSocket]] = {}  # {user_id: ws}
        self.chats_connections: dict[
            UUID, list[UUID]
        ] = {}  # {chat_id: [user_id]}all online users in each chat

    async def connect(self, websocket: WebSocket, user_id: UUID, chats_id: list[UUID]):
        """Connect user"""
        if self.active_connections.get(user_id) is None:
            self.active_connections[user_id] = []

        await websocket.accept()
        self.active_connections[user_id].append(websocket)

        for chat_id in chats_id:
            if self.chats_connections.get(chat_id) is None:
                self.chats_connections[chat_id] = []

            if user_id not in self.chats_connections[chat_id]:
                self.chats_connections[chat_id].append(user_id)

    async def disconnect(
        self,
        ws: WebSocket,
        user_id: UUID,
        chats_id: list[UUID],
    ):
        """Disconnect user"""
        if user_id not in self.active_connections.keys():
            return

        try:
            # raise exception if user is already disconnected
            await ws.close()
        except RuntimeError:
            pass

        del self.active_connections[user_id]
        for chat_id in chats_id:
            try:
                self.chats_connections[chat_id].remove(user_id)
            # TODO FIX IT
            except Exception:
                pass

    async def broadcast(
        self,
        user: ReadUserSchema,
        raw_message: CreateMessageSchema,
        message_service: message_service_factory,
        id_user_dao: id_to_username_dao,
    ):
        """Send message to all users of current chat (from message)"""

        # --- we get data and add username to it
        message = await message_service.create(raw_message)

        username_db = await id_user_dao.get_one_by_id(message.user_id)

        if not username_db:
            username_db = await id_user_dao.create(
                CreateIdToUsernameModelSchema(id=message.user_id, username=user.name)
            )

        message.author = username_db.username
        # sebd message to all users
        for user_id in self.chats_connections[message.to_chat_id]:
            for connection in self.active_connections[user_id]:
                print(connection)
                await connection.send_text(message.model_dump_json())


connection_manager_users = ConnectionManager()


@router.websocket("/")
async def websocket_endpoint(
    websocket: WebSocket,
    access_token: Annotated[str, Query()],
    message_service: message_service_factory,
    chat_service: chat_service_factory,
    jwt: jwt_manager_access,
    user_dao: user_dao_factory,
    id_user_dao: id_to_username_dao,
):
    user = await get_current_user_from_access(access_token, jwt, user_dao)

    if user is None:
        raise WebSocketException(401, "Unauthorized")

    chats = await chat_service.get_chats_by_user(user.id)
    chats_id = [i.id for i in chats]
    await connection_manager_users.connect(websocket, user.id, chats_id)
    try:
        while True:
            data_raw = await websocket.receive_json()
            data = CreateMessageSchema.model_validate(data_raw)
            data.user_id = user.id
            await connection_manager_users.broadcast(
                user, data, message_service, id_user_dao
            )

    except WebSocketDisconnect:
        print("disconnect")
        await connection_manager_users.disconnect(websocket, user.id, chats_id)


###### backend\src\endpoints\message\schemas.py
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field


class BaseMessageSchema(BaseModel):
    id: UUID
    id_in_chat: int
    message: str = Field(
        max_length=2000, description="Message must be less than 2000 characters"
    )
    user_id: UUID
    to_chat_id: UUID
    created_at: datetime
    author: str | None = None  # optional must be get from IdToUsernameModel

    model_config = ConfigDict(from_attributes=True)


class ReadMessageSchema(BaseMessageSchema):
    pass


class CreateMessageSchema(BaseModel):
    message: str = Field(
        max_length=2000, description="Message must be less than 2000 characters"
    )
    user_id: UUID | None = None
    to_chat_id: UUID


class UpdateMessageSchema(BaseModel):
    id: UUID
    message: str | None = Field(
        max_length=2000, description="Message must be less than 2000 characters"
    )


class RecivedDataDTO(CreateMessageSchema):
    pass


###### backend\src\endpoints\message\service.py
from src.core.abstract.service_base import DaoService
from src.core.abstract.storage_base import StorageBase
from src.endpoints.message.dao import MessageDaoProtocol
from src.endpoints.message.schemas import (
    CreateMessageSchema,
    ReadMessageSchema,
    UpdateMessageSchema,
)

from .models import MessageModel


class MessageService(
    DaoService[
        MessageModel, ReadMessageSchema, CreateMessageSchema, UpdateMessageSchema
    ]
):
    def __init__(
        self,
        dao: MessageDaoProtocol,
        storage_service: StorageBase,
    ):
        self.storage_service = storage_service

        super().__init__(dao)


###### backend\src\endpoints\message\__init__.py


###### backend\src\endpoints\message\id_to_username\dao.py
from typing import Protocol

from src.core.abstract.dao_base import DaoProtocol, MongoDaoImpl
from src.endpoints.message.id_to_username.schemas import (
    CreateIdToUsernameModelSchema,
    ReadIdToUsernameModelSchema,
    UpdateIdToUsernameModelSchema,
)

from .models import IdToUsernameModel


class IdToUsernameModelProtocol(
    DaoProtocol[
        IdToUsernameModel,
        ReadIdToUsernameModelSchema,
        CreateIdToUsernameModelSchema,
        UpdateIdToUsernameModelSchema,
    ],
    Protocol,
):
    pass


class IdToUsernameModelDao(
    MongoDaoImpl[
        IdToUsernameModel,
        ReadIdToUsernameModelSchema,
        CreateIdToUsernameModelSchema,
        UpdateIdToUsernameModelSchema,
    ]
):
    pass


###### backend\src\endpoints\message\id_to_username\depends.py
from typing import Annotated

from fastapi import Depends

from .dao import IdToUsernameModelDao


def get_id_to_username_dao() -> IdToUsernameModelDao:
    return IdToUsernameModelDao()


id_to_username_dao = Annotated[IdToUsernameModelDao, Depends(get_id_to_username_dao)]

__all__ = ["id_to_username_dao"]


###### backend\src\endpoints\message\id_to_username\models.py
from uuid import UUID

from beanie import Document


class IdToUsernameModel(Document):
    """
    Associate name username with his id
    This allow simple edit of username in all messages
    """

    id: UUID  # id of user
    username: str

    class Settings:
        name = "id_to_username"


###### backend\src\endpoints\message\id_to_username\schemas.py
from uuid import UUID

from pydantic import BaseModel, ConfigDict


class ReadIdToUsernameModelSchema(BaseModel):
    id: UUID
    username: str

    model_config = ConfigDict(from_attributes=True)


class CreateIdToUsernameModelSchema(BaseModel):
    id: UUID
    username: str


class UpdateIdToUsernameModelSchema(BaseModel):
    id: UUID
    username: str


###### backend\src\endpoints\role\dao.py
from typing import Protocol
from uuid import UUID

from sqlalchemy import select

from src.core.abstract.dao_base import DaoProtocol, SqlDaoImpl
from src.core.db.models.secondary_models.models import UserToGroupModel
from src.endpoints.role.models import RoleModel
from src.endpoints.role.schemas import (
    CreateRoleSchema,
    ReadRoleSchema,
    UpdateRoleSchema,
)


class RoleDaoProtocol(
    DaoProtocol[RoleModel, ReadRoleSchema, CreateRoleSchema, UpdateRoleSchema],
    Protocol,
):
    async def get_user_roles_in_group(
        self, user_id: UUID, group_id: UUID
    ) -> list[ReadRoleSchema]: ...


class RoleSqlDao(
    SqlDaoImpl[RoleModel, ReadRoleSchema, CreateRoleSchema, UpdateRoleSchema]
):
    async def get_user_roles_in_group(
        self, user_id: UUID, group_id: UUID
    ) -> list[ReadRoleSchema]:
        result = await self.session.execute(
            select(RoleModel)
            .join(UserToGroupModel, UserToGroupModel.c.user_id == user_id)
            .filter(RoleModel.group_id == group_id)
        )
        return [ReadRoleSchema.model_validate(i) for i in result.scalars().all()]


###### backend\src\endpoints\role\depends.py
from typing import Annotated

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.db.database import get_async_session
from src.endpoints.role.dao import RoleSqlDao

from .service import RoleService


def get_role_dao(session: Annotated[AsyncSession, Depends(get_async_session)]):
    return RoleSqlDao(session)


role_dao_factory = Annotated[RoleSqlDao, Depends(get_role_dao)]


def get_role_service(
    dao: role_dao_factory,
) -> RoleService:
    return RoleService(dao)


role_service_factory = Annotated[RoleService, Depends(get_role_service)]

__all__ = ["role_dao_factory", "role_service_factory"]


###### backend\src\endpoints\role\models.py
from __future__ import annotations

from datetime import datetime, timezone
from enum import Enum
from typing import TYPE_CHECKING
from uuid import uuid4

from sqlalchemy import DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import ARRAY, ENUM, UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.db.database import Base

if TYPE_CHECKING:
    from src.endpoints.group.models import GroupModel
    from src.endpoints.user.models import UserModel


class RolePermissionsEnum(Enum):
    CAN_ALL = "can_all"
    CAN_EDIT_GROUP_SETTINGS = "can_edit_group_settings"
    CAN_EDIT_ROLES = "can_edit_roles"
    CAN_CONTROL_CHATS = "can_control_chats"
    CAN_SEND_MESSAGE = "can_send_message"
    CAN_INVITE = "can_invite"


class RoleModel(Base):
    __tablename__ = "role"

    id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid4
    )
    title: Mapped[str] = mapped_column()
    permissions: Mapped[list[str]] = mapped_column(
        ARRAY(ENUM(RolePermissionsEnum, name="role_permissions")),
        default=lambda: [],
    )
    users: Mapped[list["UserModel"]] = relationship(
        secondary="user_to_role", back_populates="roles"
    )
    group_id: Mapped[UUID] = mapped_column(ForeignKey("group.id"))
    group: Mapped["GroupModel"] = relationship(back_populates="roles")
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
    )


creator_permissions = [
    RolePermissionsEnum.CAN_ALL,
    RolePermissionsEnum.CAN_EDIT_GROUP_SETTINGS,
    RolePermissionsEnum.CAN_EDIT_ROLES,
    RolePermissionsEnum.CAN_CONTROL_CHATS,
    RolePermissionsEnum.CAN_SEND_MESSAGE,
    RolePermissionsEnum.CAN_INVITE,
]

newbie_permissions = [
    RolePermissionsEnum.CAN_SEND_MESSAGE,
    RolePermissionsEnum.CAN_INVITE,
]

__all__ = [
    "RoleModel",
    "RolePermissionsEnum",
    "creator_permissions",
    "newbie_permissions",
]


###### backend\src\endpoints\role\permissions.py
from typing import Annotated
from uuid import UUID

from fastapi import Depends

from src.core.abstract.permission_base import PermissionService
from src.endpoints.role.depends import role_service_factory
from src.endpoints.role.models import RolePermissionsEnum
from src.endpoints.role.service import RoleService
from src.utils.exeptions import ModelNotFoundException, PermissionGroupDeniedError


class RolePermission(PermissionService):
    def __init__(self, service: RoleService, role_service: RoleService):
        super().__init__(service)
        self.role_service = role_service

    async def check_user_has_permission(
        self,
        permission: RolePermissionsEnum | list[RolePermissionsEnum],
        user_id: UUID,
        group_id: UUID,
    ) -> None:
        # if you use this funct you must set dao
        assert self.role_service

        try:
            roles = await self.role_service.get_user_roles_in_group(user_id, group_id)
        except ModelNotFoundException:
            raise PermissionGroupDeniedError()

        array_permissions = {perm for role in roles for perm in role.permissions}

        if isinstance(permission, RolePermissionsEnum):
            status = permission in array_permissions
        else:
            status = all(elem in array_permissions for elem in permission)

        if not status:
            raise PermissionGroupDeniedError()


def get_role_permission(
    service: role_service_factory, role_service: role_service_factory
):
    return RolePermission(service, role_service)


role_permission = Annotated[RolePermission, Depends(get_role_permission)]

__all__ = ["role_permission"]


###### backend\src\endpoints\role\router.py
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Body
from fastapi.responses import JSONResponse

from src.endpoints.auth.depends import current_user
from src.endpoints.role.permissions import role_permission

from .depends import role_service_factory
from .models import RolePermissionsEnum
from .schemas import CreateRoleSchema, ReadRoleSchema, UpdateRoleSchema

router = APIRouter(prefix="/roles_group", tags=["role"])


@router.get(
    "/{role_id}",
)
async def get_role(role_id: UUID, role_service: role_service_factory) -> ReadRoleSchema:
    return ReadRoleSchema.model_validate(await role_service.get_one_by_field(role_id))


@router.get("/permissions/me/{group_id}")
async def get_my_permissions_in_group(
    role_service: role_service_factory, user: current_user, group_id: UUID
):
    await role_service.get_user_permissions_in_group(user.id, group_id)


@router.post("/{group_id}")
async def create_role(
    group_id: UUID,
    user: current_user,
    role: Annotated[CreateRoleSchema, Body()],
    role_service: role_service_factory,
    permission: role_permission,
) -> ReadRoleSchema:
    await permission.check_user_has_permission(
        RolePermissionsEnum.CAN_EDIT_ROLES, user.id, group_id
    )

    role.group_id = group_id
    new_role = await role_service.create(role)

    return ReadRoleSchema.model_validate(new_role)


@router.patch("/{group_id}/{role_id}")
async def update_role(
    role_id: UUID,
    group_id: UUID,
    user: current_user,
    role: Annotated[UpdateRoleSchema, Body()],
    role_service: role_service_factory,
    permission: role_permission,
):
    await permission.check_user_has_permission(
        RolePermissionsEnum.CAN_EDIT_ROLES, user.id, group_id
    )

    await role_service.update(
        UpdateRoleSchema(
            id=role_id,
            **role.model_dump(exclude_none=True),
        )
    )

    return JSONResponse(status_code=200, content={"message": "Group updated"})


@router.delete("/{role_id}")
async def delete_role(
    role_id: UUID,
    role_service: role_service_factory,
    permission: role_permission,
):
    await permission.check_user_has_permission(
        RolePermissionsEnum.CAN_EDIT_ROLES, user.id, group_id
    )

    await role_service.delete(role_id)

    return JSONResponse(status_code=200, content={"message": "Group deleted"})


###### backend\src\endpoints\role\schemas.py
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict

from src.endpoints.role.models import RolePermissionsEnum


class BaseRoleSchema(BaseModel):
    id: UUID
    title: str
    group_id: UUID
    created_at: datetime
    permissions: list[RolePermissionsEnum]

    model_config = ConfigDict(from_attributes=True)


class ReadRoleSchema(BaseRoleSchema):
    pass


class CreateRoleSchema(BaseModel):
    title: str
    group_id: UUID
    permissions: list[RolePermissionsEnum] = []


class UpdateRoleSchema(BaseModel):
    id: UUID
    title: str | None = None
    permissions: list[RolePermissionsEnum] | None = None


###### backend\src\endpoints\role\service.py
from typing import TYPE_CHECKING
from uuid import UUID

from src.core.abstract.service_base import DaoService
from src.endpoints.role.models import RoleModel, RolePermissionsEnum
from src.endpoints.role.schemas import (
    CreateRoleSchema,
    ReadRoleSchema,
    UpdateRoleSchema,
)

from .dao import RoleDaoProtocol


class RoleService(
    DaoService[RoleModel, ReadRoleSchema, CreateRoleSchema, UpdateRoleSchema]
):
    def __init__(
        self,
        dao: RoleDaoProtocol,
    ):
        if TYPE_CHECKING:
            self.dao = dao

        super().__init__(dao)

    async def get_user_roles_in_group(
        self, user_id: UUID, group_id: UUID
    ) -> list[ReadRoleSchema]:
        return await self.dao.get_user_roles_in_group(user_id, group_id)

    async def get_user_permissions_in_group(
        self, user_id: UUID, group_id: UUID
    ) -> set[RolePermissionsEnum]:
        roles = await self.dao.get_user_roles_in_group(user_id, group_id)
        return {perm for role in roles for perm in role.permissions}


###### backend\src\endpoints\role\__init__.py


###### backend\src\endpoints\role\user_role\models.py
from __future__ import annotations

from uuid import UUID

from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column

from src.core.db.database import Base


class UserToRoleModel(Base):
    __tablename__ = "user_to_role"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[UUID] = mapped_column(ForeignKey("user.id"))
    role_id: Mapped[UUID] = mapped_column(ForeignKey("role.id"))


###### backend\src\endpoints\role\user_role\__init__.py


###### backend\src\endpoints\user\dao.py
from typing import Protocol

from src.core.abstract.dao_base import DaoProtocol, SqlDaoImpl
from src.endpoints.user.models import UserModel
from src.endpoints.user.schemas import (
    CreateUserSchema,
    ReadUserSchema,
    UpdateUserSchema,
)


class UserDaoProtocol(
    DaoProtocol[UserModel, ReadUserSchema, CreateUserSchema, UpdateUserSchema], Protocol
):
    pass


class UserSqlDao(
    SqlDaoImpl[UserModel, ReadUserSchema, CreateUserSchema, UpdateUserSchema]
):
    pass


###### backend\src\endpoints\user\depends.py
from typing import Annotated

from fastapi import Depends
from fastapi_users_db_sqlalchemy import SQLAlchemyUserDatabase
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.db.database import get_async_session
from src.endpoints.user.models import UserModel
from src.infrastructure.s3 import s3_service_factory

from .dao import UserSqlDao
from .service import UserService


async def get_user_db(session: Annotated[AsyncSession, Depends(get_async_session)]):
    yield SQLAlchemyUserDatabase(session, UserModel)


def get_user_dao(session: Annotated[AsyncSession, Depends(get_async_session)]):
    return UserSqlDao(session)


user_dao_factory = Annotated[UserSqlDao, Depends(get_user_dao)]


def get_user_service(
    dao: user_dao_factory,
    storage: s3_service_factory,
) -> UserService:
    return UserService(dao, storage)


user_service_factory = Annotated[UserService, Depends(get_user_service)]


__all__ = ["user_dao_factory", "user_service_factory"]


###### backend\src\endpoints\user\models.py
from __future__ import annotations

import uuid
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from fastapi_users_db_sqlalchemy import SQLAlchemyBaseUserTableUUID
from sqlalchemy import DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.db.database import Base

if TYPE_CHECKING:
    from src.endpoints.group.models import GroupModel
    from src.endpoints.role.models import RoleModel


class UserModel(SQLAlchemyBaseUserTableUUID, Base):
    id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    name: Mapped[str] = mapped_column()
    account_name: Mapped[str] = mapped_column(unique=True)
    email: Mapped[str] = mapped_column(unique=True)
    avatar_path: Mapped[str] = mapped_column(nullable=True)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
    )

    roles: Mapped[list["RoleModel"]] = relationship(
        secondary="user_to_role", back_populates="users"
    )
    groups: Mapped[list["GroupModel"]] = relationship(
        secondary="user_to_group", back_populates="users"
    )


###### backend\src\endpoints\user\permissions.py
from typing import Annotated

from fastapi import Depends

from src.core.abstract.permission_base import PermissionService
from src.endpoints.user.depends import user_dao_factory


class UserPermission(PermissionService):
    pass


def get_user_permission(dao: user_dao_factory) -> UserPermission:
    return UserPermission(dao)


user_permission = Annotated[UserPermission, Depends(get_user_permission)]

__all__ = ["user_permission"]


###### backend\src\endpoints\user\router.py
from fastapi import APIRouter, UploadFile
from fastapi.responses import JSONResponse, Response

from src.endpoints.auth.depends import current_user
from src.endpoints.group.schemas import ReadGroupSchema
from src.endpoints.user.models import UserModel
from src.endpoints.user.permissions import user_permission
from src.endpoints.user.schemas import UpdateUserSchema

from .depends import user_service_factory

# search include router in auth router.py
router = APIRouter(prefix="/users", tags=["users"])


@router.get("/avatar/me")
async def load_avatar(
    user: current_user,
    user_service: user_service_factory,
    permission: user_permission,
):
    await permission.is_has_value_model(user.id, "avatar_path")

    response = await user_service.load_avatar(f"/users/{user.id}.jpg")

    return Response(content=response, media_type="image/png")


@router.post("/avatar/me")
async def upload_avatar(
    user: current_user,
    user_service: user_service_factory,
    permission: user_permission,
    image: UploadFile,
):
    await permission.check_exist_by_id(user.id, UserModel)

    path = f"users/{str(user.id)}.jpg"
    await user_service.upload_avatar(path, image)
    await user_service.update(UpdateUserSchema(id=user.id, avatar_path=path))
    return JSONResponse(status_code=200, content={"message": "Avatar uploaded"})


@router.get("/permissions/me")
async def get_my_groups(
    user: current_user,
    user_service: user_service_factory,
) -> list[ReadGroupSchema]:
    return await user_service.get_permissions_in_group(user.id)


###### backend\src\endpoints\user\schemas.py
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict


class BaseUserSchema(BaseModel):
    id: UUID
    name: str
    account_name: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class ReadUserSchema(BaseUserSchema):
    pass


class CreateUserSchema(BaseModel):
    name: str
    account_name: str
    email: str


class UpdateUserSchema(BaseModel):
    id: UUID
    name: str | None = None
    avatar_path: str | None = None


###### backend\src\endpoints\user\service.py
from typing import TYPE_CHECKING

from fastapi import UploadFile

from src.core.abstract.service_base import DaoService
from src.core.abstract.storage_base import StorageBase
from src.endpoints.user.schemas import (
    CreateUserSchema,
    ReadUserSchema,
    UpdateUserSchema,
)

from .dao import UserDaoProtocol
from .models import UserModel


class UserService(
    DaoService[UserModel, ReadUserSchema, CreateUserSchema, UpdateUserSchema]
):
    def __init__(
        self,
        dao: UserDaoProtocol,
        storage_service: StorageBase,
    ):
        self.storage_service = storage_service

        if TYPE_CHECKING:
            self.dao = dao

        super().__init__(dao)

    async def load_avatar(self, key: str) -> bytes:
        return await self.storage_service.get(key)

    async def upload_avatar(self, key: str, value: UploadFile) -> None:
        value_bytes = await value.read()
        return await self.storage_service.save(key, value_bytes)


###### backend\src\endpoints\user\__init__.py


###### backend\src\infrastructure\__init__.py


###### backend\src\infrastructure\s3\depends.py
from typing import Annotated

from fastapi import Depends

from config import global_setttigns, settings

from .s3_service import S3BucketService


def s3_bucket_service_factory() -> S3BucketService:
    return S3BucketService(
        settings.S3_BUCKET_NAME,
        settings.S3_PATH + ":" + global_setttigns.S3_PORT,
        global_setttigns.S3_USER,
        global_setttigns.S3_PASSWORD,
    )


s3_service_factory = Annotated[S3BucketService, Depends(s3_bucket_service_factory)]


###### backend\src\infrastructure\s3\s3_service.py
import logging
from io import BytesIO

import aioboto3
from botocore.exceptions import ClientError
from fastapi import HTTPException, UploadFile
from PIL import Image

from src.core.abstract.storage_base import StorageBase
from src.utils.exeptions import ServerException, ServiceNotFoundException

logger = logging.getLogger(__name__)


class S3BucketService(StorageBase):
    def __init__(
        self, bucket_name: str, endpoint: str, access_key: str, secret_key: str
    ):
        self.bucket_name = bucket_name
        self.endpoint = endpoint
        self.access_key = access_key
        self.secret_key = secret_key

    async def _create_s3_client(self):
        """
        Create S3 client context
        """
        session = aioboto3.Session()
        # return context manager
        return lambda: session.client(
            "s3",
            endpoint_url=self.endpoint,
            aws_access_key_id=self.access_key,
            aws_secret_access_key=self.secret_key,
        )

    async def save(
        self,
        key: str,
        value: str | bytes,
    ) -> None:
        """
        Upload file to S3
        key - path to file
        value - file
        """
        client_context = await self._create_s3_client()
        destination_file_name = key

        if isinstance(value, bytes):
            buffer = BytesIO(value)
        else:
            buffer = BytesIO(value.encode("utf-8"))

        async with client_context() as client:
            await client.upload_fileobj(buffer, self.bucket_name, destination_file_name)

    async def list_objects(self, key: str) -> list[str]:
        """
        List objects in the bucket
        key - path to file
        """
        client_context = await self._create_s3_client()

        async with client_context() as client:
            response = await client.list_objects_v2(Bucket=self.bucket_name, Prefix=key)

        storage_content: list[str] = []

        try:
            contents = response["Contents"]
        except KeyError:
            return storage_content

        for item in contents:
            storage_content.append(item["Key"])

        return storage_content

    async def get(self, key: str, chunk_size: int = 69 * 1024):
        """
        Get file object from S3
        key - path to file
        """

        client_context = await self._create_s3_client()
        async with client_context() as client:
            try:
                file_obj = await client.get_object(Bucket=self.bucket_name, Key=key)

                file_data = await file_obj["Body"].read()

            except ClientError as e:
                if e.response["Error"]["Code"] == "NoSuchKey":
                    raise HTTPException(  # noqa: B904
                        status_code=404,
                        detail="File not found",
                    )
                logger.error(str(e))
                raise HTTPException(500, "Unknown error")

        if file_data is None:
            raise ServiceNotFoundException()

        return file_data

    async def delete(self, key: str) -> None:
        """
        Delete file object from S3
        key - path to file
        """

        client_context = await self._create_s3_client()
        async with client_context() as client:
            client.delete_object(Bucket=self.bucket_name, Key=key)

    async def save_image(self, key: str, value: UploadFile):
        """Upload file to S3
        key - path to file
        value - image"""
        if key[len(key) - 4 :] != ".jpg":
            raise ServerException()

        try:
            # convert image to .jpg and save
            with Image.open(BytesIO(await value.read())) as img:
                img = img.convert("RGB")
                img_byte_arr = BytesIO()
                img.save(img_byte_arr, format="JPEG")
                img_byte_arr.seek(0)

            await self.save(key, img_byte_arr.getvalue())
        except Exception:
            raise ServerException()

        return key


###### backend\src\infrastructure\s3\__init__.py
from .depends import s3_bucket_service_factory, s3_service_factory
from .s3_service import S3BucketService

__all__ = ["s3_bucket_service_factory", "S3BucketService", "s3_service_factory"]


###### backend\src\utils\depends.py
from fastapi.security import OAuth2PasswordBearer

# This is used only for authorize in docs page
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="auth/access_token",
    scheme_name="access_token",
)


###### backend\src\utils\exeptions.py
class ServiceNotFoundException(Exception):
    message = "File not found"


class NotFoundException(Exception):
    message = "Not found"


class ServerException(Exception):
    message = "Server error"


class FieldIsNoneException(Exception):
    message = "Field is None"


class NotFoundModelException(Exception):
    """raise when the resulting model object is none"""

    message = "Model not found"


class PermissionNotHasAttributeError(Exception):
    """raise when the required field is not found in the model"""

    message = "Permission no has data"


class PermissionGroupDeniedError(Exception):
    """raise when user does not have permission setted in group"""

    message = "Permission group denied"


class ModelNotFoundException(Exception):
    message = "Model not found"


###### backend\src\utils\jwt.py
import datetime
from typing import Generic, TypeVar

import jwt
from pydantic import BaseModel

DataSchema = TypeVar("DataSchema", bound=BaseModel)


class JWTManager(Generic[DataSchema]):
    """
    Class for managing JWT tokens
    """

    def __init__(
        self,
        secret_key: str,
        data_schema: type[DataSchema],
        algorithm: str = "HS256",
        expiration_minutes: int = 30,
    ):
        self.data_schema = data_schema
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.expiration_minutes = expiration_minutes

    def encode(self, payload: DataSchema) -> str:
        data = payload.model_dump()
        data["exp"] = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(
            minutes=self.expiration_minutes
        )
        token = jwt.encode(data, self.secret_key, algorithm=self.algorithm)
        return token

    def decode(self, token: str) -> DataSchema:
        decoded = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
        return self.data_schema.model_validate(decoded)


__all__ = ["JWTManager"]


###### backend\src\utils\types.py
from typing import TypeVar

from beanie import Document
from pydantic import BaseModel

from src.core.db.database import Base

ModelType = TypeVar("ModelType", bound=Base | Document, covariant=True)
ReadSchemaType = TypeVar("ReadSchemaType", bound=BaseModel)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel, contravariant=True)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel, contravariant=True)


###### backend\src\utils\__init__.py


###### backend\tests\endpoints\conftest.py
import sys

import pytest_asyncio
from httpx import ASGITransport, AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

sys.path.append("./")

from config import settings
from main import app
from src.core.db.database import Base, async_session_maker, engine
from src.core.db.models import GroupModel

assert settings.TEST_MODE


@pytest_asyncio.fixture
async def client() -> AsyncClient:
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as c:
        yield c


@pytest_asyncio.fixture(scope="function", autouse=True)
async def setup_database():
    async with engine.connect() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)
        await conn.commit()

    yield

    async with engine.connect() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.commit()


@pytest_asyncio.fixture(scope="function")
async def session(setup_database):
    async with async_session_maker() as session:
        yield session


@pytest_asyncio.fixture(scope="function")
async def authorization(session: AsyncSession):
    group = GroupModel(title="Test group")
    session.add(group)
    await session.commit()
    await session.refresh(group)

    yield group


@pytest_asyncio.fixture(scope="function")
async def group(session: AsyncSession):
    group = GroupModel(title="Test group")
    session.add(group)
    await session.commit()
    await session.refresh(group)

    yield group


# @pytest_asyncio.fixture(scope="function")
# async def s3():
#     s3 = s3_bucket_service_factory()
#     yield s3


# @pytest_asyncio.fixture(scope="function")
# async def chat(session: AsyncSession, group: GroupModel):
#     chat = ChatModel(title="Test chat", group_id=group.id)
#     session.add(chat)
#     await session.commit()
#     await session.refresh(chat)
#     yield chat


# @pytest_asyncio.fixture(scope="function")
# async def personal_chat(session: AsyncSession):
#     personal_chat = PersonalChatModel(title="Test personal chat")
#     session.add(personal_chat)
#     await session.commit()
#     await session.refresh(personal_chat)
#     yield personal_chat


# @pytest_asyncio.fixture(scope="function")
# async def role_group(session: AsyncSession, group: GroupModel):
#     role_group = RoleModel(title="Test role group", group_id=group.id)
#     session.add(role_group)
#     await session.commit()
#     await session.refresh(role_group)
#     yield role_group


###### frontend\next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


###### frontend\next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  allowedDevOrigins: [
    "http://127.0.0.1:3000",
    "http://localhost:3000",
    "http://localhost:8000",
    "http://127.0.0.1:8000",
    "http://192.168.230.121:3000",
  ],
};

export default nextConfig;


###### frontend\plopfile.js
// plopfile.js
module.exports = function (plop) {
  plop.setHelper('pascalCase', (text) => {
    return text
      .split(/[-_\s]+/)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  });

  // Генератор компонента
  plop.setGenerator('component', {
    description: 'Create a React component',
    prompts: [
      {
        type: 'input',
        name: 'name',
        message: 'Component name (PascalCase):',
      },
      {
        type: 'input',
        name: 'folder',
        message: 'Parent folder (e.g., "features/header"):',
        default: 'shared/ui',
      },
    ],
    actions: [
      {
        type: 'add',
        path: 'src/{{folder}}/{{name}}/{{name}}.tsx',
        templateFile: 'plop-templates/component.hbs',
      },
      {
        type: 'add',
        path: 'src/{{folder}}/{{name}}/{{name}}.module.scss',
        templateFile: 'plop-templates/styles.hbs',
      },
      {
        type: 'add',
        path: 'src/{{folder}}/{{name}}/index.ts',
        templateFile: 'plop-templates/index.hbs',
      },
    ],
  });
};


###### frontend\public\service-worker.js
const CACHE_NAME = "image-cache-v1";
self.accessToken = null;
self.BACKEND_URL = null;
self.ALLOWED_ORIGINS = [];
self.ALLOWED_CACHED_PATHS = [];

self.addEventListener("message", (event) => {
  const { type, payload } = event.data;
  if (type === "SET_PARAMS") {
    self.BACKEND_URL = payload.BACKEND_URL;
    self.ALLOWED_ORIGINS = payload.ALLOWED_ORIGINS;
    self.ALLOWED_CACHED_PATHS = payload.ALLOWED_CACHED_PATHS;
  }
});

const accessTokenMiddleware = async (request) => {
  // request access token from api when we get a 401 code
  // in other cases we set the access token in the request headers
  const fetchAccessToken = async () => {
    const response = await fetch(`${self.BACKEND_URL}/api/auth/access_token`, {
      method: "POST",
      credentials: "include",
    });

    if (!response.ok) {
      console.log("Failed to fetch access token");
      return;
    }

    const data = await response.json();
    return data.access_token;
  };

  const modified = new Request(request, {
    headers: new Headers({
      ...Object.fromEntries(request.headers.entries()),
      Authorization: `Bearer ${self.accessToken}`,
    }),
  });

  const response = await fetch(modified);

  if (response.status === 401) {
    self.accessToken = await fetchAccessToken();
    return fetch(
      new Request(request, {
        headers: new Headers({
          ...Object.fromEntries(request.headers.entries()),
          Authorization: `Bearer ${self.accessToken}`,
        }),
      })
    );
  }

  return response;
};

self.addEventListener("fetch", (event) => {
  const { request } = event;
  const url = new URL(request.url);

  const isAllowed = self.ALLOWED_ORIGINS.some((origin) => {
    const pathname = url.pathname;

    for (const path of self.ALLOWED_CACHED_PATHS) {
      if (pathname.includes(path) && url.href.startsWith(origin)) {
        return true;
      }
    }
    return false;
  });
  if (isAllowed) {
    //caching images
    event.respondWith(
      caches.open(CACHE_NAME).then((cache) =>
        cache.match(request).then((cachedResponse) => {
          if (cachedResponse) return cachedResponse;

          return accessTokenMiddleware(request).then((networkResponse) => {
            if (networkResponse.ok) {
              cache.put(request, networkResponse.clone());
            }
            return networkResponse;
          });
        })
      )
    );
  } else if (!isAllowed && request.url.startsWith(self.BACKEND_URL)) {
    // for all query to backend
    event.respondWith(accessTokenMiddleware(request));
  }
});


###### frontend\src\app\layout.tsx
import type { Metadata } from "next";
import "./globals.css";
import { Providers } from "@/app/provider";
import { Roboto } from "next/font/google";

const roboto = Roboto();

export const metadata: Metadata = {
  title: "Margelet",
  description: "a new messenger",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={roboto.className}>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}


###### frontend\src\app\page.tsx
import Login from '@/_pages/login/ui';

export default Login;


###### frontend\src\app\provider.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactNode, useState, StrictMode, useEffect } from "react";
import { Provider } from "react-redux";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

import { OpenAPI as OpenAPIConfig } from "@/shared/api/requests/core/OpenAPI";
import store from "./store";
import settings from "@/shared/config";
import WebsocketProvider from "../shared/lib/providers/websocket_provider";
import { usePathname } from "next/navigation";

OpenAPIConfig.BASE = settings.NEXT_PUBLIC_API_URL!;
OpenAPIConfig.CREDENTIALS = settings.CREDENTIALS as
  | "include"
  | "omit"
  | "same-origin";
OpenAPIConfig.WITH_CREDENTIALS = true;

export function Providers({ children }: { children: ReactNode }) {
  const pathname = usePathname();
  const [queryClient] = useState(() => new QueryClient({}));

  useEffect(() => {
    if (typeof window == "undefined") {
      return;
    }

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/service-worker.js")
        .then((reg) => console.log("Service Worker registered"))
        .catch((err) => console.error("Service Worker registration failed"));

      navigator.serviceWorker.ready.then((registration) => {
        registration.active.postMessage({
          type: "SET_PARAMS",
          payload: {
            BACKEND_URL: settings.NEXT_PUBLIC_API_URL,
            ALLOWED_ORIGINS: [settings.NEXT_PUBLIC_API_URL],
            ALLOWED_CACHED_PATHS: settings.NEXT_PUBLIC_ALLOWED_CACHED_PATHS,
          },
        });
      });
    }
  }, []);

  return (
    <StrictMode>
      <Provider store={store}>
        <QueryClientProvider client={queryClient}>
          {/* websoket not needed in other pages */}
          {pathname == "/communication" ? (
            <WebsocketProvider>{children}</WebsocketProvider>
          ) : (
            children
          )}

          <ReactQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      </Provider>
    </StrictMode>
  );
}

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch;


###### frontend\src\app\store.ts
import { configureStore } from "@reduxjs/toolkit";
import group from "@/entities/group/model/slice";
import chat from "@/entities/chat/model/slice";
import accessToken from "@/features/auth/model/slice";

const store = configureStore({
  reducer: { group, chat, accessToken },
});

export default store;
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;


###### frontend\src\app\communication\page.tsx
import Communication from '@/_pages/communication/ui';

export default Communication;


###### frontend\src\app\communication\create_group\page.tsx
import CreateGroup from '@/_pages/create_group/ui';

export default CreateGroup;


###### frontend\src\app\communication\join_group\[id]\page.tsx
import JoinGroup from "@/_pages/join_group/ui";

export default JoinGroup;


###### frontend\src\app\communication\settings\page.tsx
import GroupSettings from "@/_pages/group_settings/ui";

export default GroupSettings;


###### frontend\src\app\registration\page.tsx
import Registration from "@/_pages/registration/ui";

export default Registration;


###### frontend\src\entities\chat\model\index.ts
import {
  useChatServiceDeleteApiChatsByChatId,
  useChatServiceGetApiChatsByChatId,
  useChatServiceGetApiChatsGroupChatsByGroupId,
  useChatServicePatchApiChatsByChatId,
  useChatServiceGetApiChatsChatsMe,
  useChatServicePostApiChatsByGroupId,
  useChatServiceGetApiChatsGroupChatsByGroupIdKey,
} from "@/shared/api/queries";

export const useApiChat = {
  get: useChatServiceGetApiChatsByChatId,
  getGroupChats: useChatServiceGetApiChatsGroupChatsByGroupId,
  create: useChatServicePostApiChatsByGroupId,
  update: useChatServicePatchApiChatsByChatId,
  delete: useChatServiceDeleteApiChatsByChatId,
  getChatsMe: useChatServiceGetApiChatsChatsMe,
  getGroupChatsKey: useChatServiceGetApiChatsGroupChatsByGroupIdKey,
};

export type {
  ReadChatSchema,
  UpdateChatSchema,
  CreateChatSchema,
} from "@/shared/api/requests";


###### frontend\src\entities\chat\model\slice.ts
import { createSlice } from '@reduxjs/toolkit';

interface ChatState {
  id: string | null;
}

const initialState: ChatState = {
  id: null,
};

export const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    setChatId: (state, action) => {
      state.id = action.payload;
    },
  },
});

export const { setChatId } = chatSlice.actions;

export default chatSlice.reducer;


###### frontend\src\entities\chat\ui\chat.module.scss
.chat {
  cursor: pointer;
  padding: 10px 12px;
  border-radius: 8px;
  transition: background-color 0.2s ease;
  font-size: 14px;
  color: #1a202c;
  background-color: var(--primary-background);
  display: flex;
  align-items: center;

  &:hover {
    background-color: var(--second);
  }
}


###### frontend\src\entities\chat\ui\chat.tsx
import { HTMLAttributes, MouseEventHandler } from 'react';
import clsx from 'clsx';

import styles from './chat.module.scss';

export interface ChatProps extends HTMLAttributes<HTMLDivElement> {
  title: string;
}

export const Chat = ({ title, className, onClick }: ChatProps) => {
  return (
    <div className={clsx(styles.chat, className)} onClick={onClick}>
      # {title}
    </div>
  );
};

export default Chat;


###### frontend\src\entities\chat\ui\index.ts
import Chat from './chat';

export default Chat;
export type { ChatProps } from './chat';

###### frontend\src\entities\group\model\index.ts
import {
  useGroupServiceGetApiGroupsByGroupId,
  useGroupServiceGetApiGroupsAvatarByGroupId,
  useGroupServiceGetApiGroupsPanoramaByGroupId,
  useGroupServiceDeleteApiGroupsByGroupId,
  useGroupServicePatchApiGroupsByGroupId,
  useGroupServicePostApiGroups,
  useGroupServicePostApiGroupsAvatarByGroupId,
  useGroupServicePostApiGroupsPanoramaByGroupId,
  useGroupServiceGetApiGroupsInviteByGroupId,
  useGroupServiceGetApiGroupsUserGroupsMe,
  useGroupServiceGetApiGroupsUserGroupsByUserId,
  useGroupServiceGetApiGroupsUserGroupsMeKey,
} from "@/shared/api/queries";
import settings from "@/shared/config";

export const useApiGroup = {
  get: useGroupServiceGetApiGroupsByGroupId,
  delete: useGroupServiceDeleteApiGroupsByGroupId,
  patch: useGroupServicePatchApiGroupsByGroupId,
  post: useGroupServicePostApiGroups,
  loadAvatar: useGroupServiceGetApiGroupsAvatarByGroupId,
  uploadAvatar: useGroupServicePostApiGroupsAvatarByGroupId,
  uploadPanorama: useGroupServicePostApiGroupsPanoramaByGroupId,
  getInviteToken: useGroupServiceGetApiGroupsInviteByGroupId,
  getMyGroups: useGroupServiceGetApiGroupsUserGroupsMe,
  getGroupsByUserId: useGroupServiceGetApiGroupsUserGroupsByUserId,
  getMyGroupsKey: useGroupServiceGetApiGroupsUserGroupsMeKey,
  loadPanorama: (groupId: string) =>
    fetch(`${settings.NEXT_PUBLIC_API_URL}/api/groups/panorama/${groupId}`, {
      credentials: "include",
    }).then((res) => {
      if (!res.ok) throw new Error(res.statusText);
      return res.blob();
    }),
  avatar: (groupId: string) => `/api/groups/avatar/${groupId}`,
};

export type {
  ReadGroupSchema,
  CreateGroupSchema,
  UpdateGroupSchema,
} from "@/shared/api/requests";


###### frontend\src\entities\group\model\slice.ts
import { createSlice } from "@reduxjs/toolkit";

interface GroupState {
  id: string | null;
  title: string | null;
  search_query: string | null;
  avatar_path: string | null;
  panorama_path: string | null;
}

const initialState: GroupState = {
  id: null,
  title: null,
  search_query: null,
  avatar_path: null,
  panorama_path: null,
};

export const groupSlice = createSlice({
  name: "group",
  initialState,
  reducers: {
    setGroupData: (
      state,
      action: { payload: { id: string | null; title: string | null } }
    ) => {
      state.id = action.payload.id;
      state.title = action.payload.title;
    },

    setSearchQuery: (state, action: { payload: string }) => {
      state.search_query = action.payload;
    },

    setAvatarPath: (state, action: { payload: string | null }) => {
      state.avatar_path = action.payload;
    },

    setPanoramaPath: (state, action: { payload: string | null }) => {
      state.panorama_path = action.payload;
    },
  },
});

export const { setGroupData, setSearchQuery, setAvatarPath, setPanoramaPath } =
  groupSlice.actions;

export default groupSlice.reducer;


###### frontend\src\entities\group\ui\group_card.module.scss
.group_card {
  display: flex;
  flex-direction: row;
  align-items: center;
  height: 60px;
  width: 100%;
  font-size: 14px;
  border-radius: 25px 15px 15px 25px;

  &:hover {
    cursor: pointer;
    background-color: #f7f7f7;
  }

  .avatar {
    height: inherit;
    flex-shrink: 0;
    width: 60px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: var(--primary-background);
  }

  .information {
    margin-left: 20px;

    .title {
      font-weight: 800;
    }
  }

  .addition {
    margin-left: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 14px;

    .last_message_time {
      font-weight: 800;
    }

    .amount_unread_messages {
      width: 50px;
      height: 25px;
      border-radius: 10px;
      background-color: var(--primary-background);
      font-weight: 800;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
    }
  }
}


###### frontend\src\entities\group\ui\group_card.tsx
"use client";
import { HTMLAttributes, MouseEventHandler, useEffect } from "react";
import Image from "next/image";

import styles from "./group_card.module.scss";
import { useApiGroup } from "../model";
import { useAppDispatch } from "@/shared/lib/hooks";
import { setPanoramaPath } from "../model/slice";

export interface GroupCardProps extends HTMLAttributes<HTMLDivElement> {
  id: string;
  image_url?: string;
  data: any;
}

export const GroupCard = ({ id, image_url, onClick, data }: GroupCardProps) => {
  const dispatch = useAppDispatch();

  const onClickHandler: MouseEventHandler<HTMLDivElement> = (e) => {
    //clear panorama when select other group
    dispatch(setPanoramaPath(null));

    // if panorama path not set, app will not request image from backend
    if (data?.panorama_path) {
      dispatch(setPanoramaPath(data.panorama_path));
    }

    onClick && onClick(e);
  };

  return (
    data && (
      <div onClick={onClickHandler} className={styles.group_card}>
        {image_url ? (
          <Image
            src={image_url}
            width={65}
            height={65}
            className={styles.avatar}
            alt="avatar"
          ></Image>
        ) : (
          <div className={styles.avatar}>{data.title.slice(0, 2)}</div>
        )}
        <div className={styles.information}>
          <div className={styles.title}>{data.title}</div>
          {/* <div className={styles.last_message}>что то написано</div> */}
        </div>
        {/* <div className={styles.addition}>
          <div className={styles.last_message_time}>52:38</div>
          <div className={styles.amount_unread_messages}>208</div>
        </div> */}
      </div>
    )
  );
};

export default GroupCard;


###### frontend\src\entities\group\ui\index.ts
import GroupCard from './group_card';

export type { GroupCardProps } from './group_card';
export default GroupCard;


###### frontend\src\entities\message\model\index.ts
import {
  useMessagesServiceDeleteApiMessagesByMessageId,
  useMessagesServiceGetApiMessagesByMessageId,
  useMessagesServiceGetApiMessagesChatByChatId,
  useMessagesServiceGetApiMessagesChatByChatIdKey,
  useMessagesServicePatchApiMessagesByMessageId,
  useMessagesServicePostApiMessages,
} from "@/shared/api/queries";

export const useApiMessage = {
  get: useMessagesServiceGetApiMessagesByMessageId,
  getAllMessageChat: useMessagesServiceGetApiMessagesChatByChatId,
  create: useMessagesServicePostApiMessages,
  update: useMessagesServicePatchApiMessagesByMessageId,
  delete: useMessagesServiceDeleteApiMessagesByMessageId,
  getAllMessageChatKey: useMessagesServiceGetApiMessagesChatByChatIdKey,
};

export type {
  CreateMessageSchema,
  ReadMessageSchema,
  UpdateMessageSchema,
} from "@/shared/api/requests";


###### frontend\src\entities\message\ui\index.ts
import Message from './message';

export default Message;
export type { MessageProps } from './message';

###### frontend\src\entities\message\ui\message.module.scss
.message {
  width: 100%;
  min-height: 80px;

  display: flex;
  flex-direction: row;
  align-items: center;
}

.avatar {
  flex-shrink: 0;
  width: 45px;
  height: 45px;
  border-radius: 50%;
  background-color: var(--primary-background);
  margin-right: 15px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.author {
  font-weight: 800;
  font-size: 16px;
  margin-bottom: 10px;
}

.text {
  font-size: 20px;
}

.time {
  align-self: flex-end;
  margin-left: 10px;
  margin-bottom: -7px;
  font-style: 14px;
}


###### frontend\src\entities\message\ui\message.tsx
import { HTMLAttributes } from 'react';

import styles from './message.module.scss';

export interface MessageProps extends HTMLAttributes<HTMLDivElement> {
  author: string;
  text: string;
  time: string;
}

export const Message = ({ author, text, time }: MessageProps) => {
  return (
    <div className={styles.message}>
      <div className={styles.avatar}>{author.slice(0, 2)}</div>
      <div className={styles.content}>
        <div className={styles.author}>{author}</div>
        <div className={styles.text}>{text}</div>
      </div>
      <div className={styles.time}>
        {new Date(time).toLocaleString([], {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
        })}
      </div>
    </div>
  );
};

export default Message;


###### frontend\src\entities\user\model\index.ts
import {
  useUsersServiceGetApiUsersAvatarMe,
  useUsersServiceGetApiUsersById,
  useUsersServiceGetApiUsersMe,
} from "@/shared/api/queries";

export const useApiUser = {
  getAvatar: useUsersServiceGetApiUsersAvatarMe,
  getUserById: useUsersServiceGetApiUsersById,
  get: useUsersServiceGetApiUsersMe,
};

export type {} from "@/shared/api/requests";


###### frontend\src\entities\user\ui\index.ts
import UserCard from './user_card';

export default UserCard;
export type { UserCardProps } from './user_card';

###### frontend\src\entities\user\ui\user_card.module.scss
.user_card {
  border-radius: 50%;
  background-color: var(--primary-background);
  display: flex;
  justify-content: center;
  align-items: center;
}

.default {
  width: 50px;
  height: 50px;
}

.small {
  width: 30px;
  height: 30px;
}


###### frontend\src\entities\user\ui\user_card.tsx
import { HTMLAttributes } from "react";

import styles from "./user_card.module.scss";
import { useApiUser } from "../model";
import clsx from "clsx";

export interface UserCardProps extends HTMLAttributes<HTMLDivElement> {
  styleType?: "small" | "default";
}

export const UserCard = ({
  styleType = "default",
  ...props
}: UserCardProps) => {
  const { data } = useApiUser.get();

  if (!data) {
    return null;
  }

  return (
    <div
      {...props}
      className={clsx(
        styleType == "default" ? styles.default : styles.small,
        styles.user_card
      )}
    >
      {data.name.slice(0, 2)}
    </div>
  );
};

export default UserCard;


###### frontend\src\features\auth\lib\index.ts
export { useIsAuth } from './hooks';
export { useRedirectAuth } from './hooks';


###### frontend\src\features\auth\lib\hooks\index.ts
export { useIsAuth } from './is_auth';
export { useRedirectAuth } from './redirect_auth';


###### frontend\src\features\auth\lib\hooks\is_auth.tsx
"use client";
import { useEffect, useState } from "react";
import { apiAuth } from "../../model";
import { useQueryClient } from "@tanstack/react-query";

export const useIsAuth = (isGetAccessToken?: boolean) => {
  //no work
  const { data, isSuccess } = apiAuth.getAccessToken();
  const [result, setResult] = useState<boolean | typeof data>(false);

  useEffect(() => {
    if (isSuccess && data) {
      if (isGetAccessToken) {
        setResult(data);
      } else {
        setResult(true);
      }
    }
  }, [isSuccess, data, isGetAccessToken]);

  return result;
};


###### frontend\src\features\auth\lib\hooks\redirect_auth.tsx
"use client";
import { useRouter, usePathname } from "next/navigation";

import { useIsAuth } from "./is_auth";
import { useEffect } from "react";

export const useRedirectAuth = () => {
  // use for redirect to login if not auth and to communication if auth
  const pathname = usePathname();
  const isAuth = useIsAuth();
  const router = useRouter();

  useEffect(() => {
    console.log("pathname", isAuth);
    if (!isAuth && pathname !== "/") {
      router.push("/");
    }
  }, []);
};


###### frontend\src\features\auth\model\index.ts
import {
  useAuthServicePostApiAuthAccessToken,
  useAuthServicePostApiAuthJwtLogout,
} from "@/shared/api/queries";

export const apiAuth = {
  postAccessToken: useAuthServicePostApiAuthAccessToken,
  logout: useAuthServicePostApiAuthJwtLogout,
};


###### frontend\src\features\auth\model\slice.ts
import { createSlice } from "@reduxjs/toolkit";

interface AccessTokenState {
  token: string | null;
}

const initialState: AccessTokenState = {
  token: null,
};

export const accessTokenSlice = createSlice({
  name: "access_token",
  initialState,
  reducers: {
    setAccessToken: (state, action: { payload: string }) => {
      state.token = action.payload;
    },
  },
});

export const { setAccessToken } = accessTokenSlice.actions;

export default accessTokenSlice.reducer;


###### frontend\src\features\auth\types\index.ts


###### frontend\src\features\login\model\index.ts
import { useAuthServicePostApiAuthJwtLogin } from "@/shared/api/queries";

export const apiLogin = {
  login: useAuthServicePostApiAuthJwtLogin,
};

export type { Body_auth_db_cookie_login_api_auth_jwt_login_post } from "@/shared/api/requests";


###### frontend\src\features\login\ui\index.ts
import LoginForm from './login';

export default LoginForm;
export type { LoginFormProps } from './login';


###### frontend\src\features\login\ui\login.module.scss
.form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}


###### frontend\src\features\login\ui\login.tsx
"use client";
import { FormEventHandler, HTMLAttributes, useEffect } from "react";
import { useRouter } from "next/navigation";

import InputText from "@/shared/ui/inputs/input_text";
import { apiLogin } from "../model";
import styles from "./login.module.scss";
import Button from "@/shared/ui/button";
import Link from "next/link";

export interface LoginFormProps extends HTMLAttributes<HTMLDivElement> {}

export const LoginForm = ({}: LoginFormProps) => {
  const loginApi = apiLogin.login();
  const router = useRouter();

  const onSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
    e.preventDefault();

    const formData = new FormData(e.currentTarget);

    await loginApi
      .mutateAsync({
        formData: {
          username: formData.get("email") as string,
          password: formData.get("password") as string,
        },
      })
      .then((data) => {
        console.log(data);
        router.push("/communication");
      })
      .catch((reason) => {
        console.log(
          reason.status == 400 && alert("Вы ввели неверную почту или пароль")
        );
      });
  };

  return (
    <form onSubmit={onSubmit} className={styles.form}>
      <InputText
        type="text"
        name="email"
        labelText="Email"
        placeholder="example@mail.com"
        classNameInput={styles.login_input}
      />
      <InputText
        type="password"
        name="password"
        labelText="Пароль"
        placeholder="*********"
        classNameInput={styles.login_input}
      />
      <Button type="submit" className={styles.submit}>
        Войти
      </Button>
      <Link href="/registration">
        <Button styleType="invert">Зарегистрироваться</Button>
      </Link>
    </form>
  );
};

export default LoginForm;


###### frontend\src\features\registration\ui\index.ts
import Registration from "./registration";

export default Registration;
export type { RegistrationFormProps } from "./registration";


###### frontend\src\features\registration\ui\registration.module.scss
.form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.submit {
  margin-top: 10px;
}


###### frontend\src\features\registration\ui\registration.tsx
"use client";
import { HTMLAttributes, FormEventHandler } from "react";
import { useRouter } from "next/navigation";
import { useAuthServicePostApiAuthRegister } from "@/shared/api/queries";
import InputText from "@/shared/ui/inputs/input_text";
import Button from "@/shared/ui/button";
import styles from "./registration.module.scss";
import Link from "next/link";

export interface RegistrationFormProps
  extends HTMLAttributes<HTMLFormElement> {}

const RegistrationForm = ({}: RegistrationFormProps) => {
  const registerApi = useAuthServicePostApiAuthRegister();
  const router = useRouter();

  const onSubmit: FormEventHandler<HTMLFormElement> = (e) => {
    e.preventDefault();

    const formData = new FormData(e.currentTarget);

    registerApi.mutate({
      requestBody: {
        name: formData.get("name") as string,
        account_name: formData.get("account_name") as string,
        email: formData.get("email") as string,
        password: formData.get("password") as string,
      },
    });
    router.push("/");
  };

  return (
    <form onSubmit={onSubmit} className={styles.form}>
      <InputText
        type="text"
        name="name"
        labelText="Имя пользователя"
        placeholder="Ivan"
        classNameInput={styles.registration_input}
      />
      <InputText
        type="text"
        name="account_name"
        labelText="Уникальное имя профиля"
        placeholder="example"
        classNameInput={styles.registration_input}
        autoComplete="off"
      />
      <InputText
        type="text"
        name="email"
        labelText="Email"
        placeholder="example@mail.com"
        classNameInput={styles.registration_input}
      />
      <InputText
        type="password"
        name="password"
        labelText="Пароль"
        placeholder="*********"
        classNameInput={styles.registration_input}
      />
      <Button type="submit" className={styles.submit}>
        Зарегистрироваться
      </Button>
      <Link href="/">
        <Button styleType="invert">Войти</Button>
      </Link>
    </form>
  );
};

export default RegistrationForm;


###### frontend\src\shared\config.ts
const settings = {
  NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
  NEXT_PUBLIC_API_WS_URL: process.env.NEXT_PUBLIC_API_WS_URL,
  NEXT_PUBLIC_FRONTEND_URL: process.env.NEXT_PUBLIC_FRONTEND_URL,
  // you can set filter for url. example: "/path/image"
  NEXT_PUBLIC_ALLOWED_CACHED_PATHS: ["/groups/panorama/", "/groups/avatar/"],
  CREDENTIALS: "include",
};

export default settings;


###### frontend\src\shared\lib\hooks\index.ts
export * from "./redux_hooks";


###### frontend\src\shared\lib\hooks\redux_hooks.ts
import { useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from '@/app/store';

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>();
export const useAppSelector = useSelector.withTypes<RootState>();


###### frontend\src\shared\lib\hooks\use_isomorphic_layout.ts
import { useEffect, useLayoutEffect } from "react";

const useIsomorphicLayoutEffect =
  typeof window !== "undefined" ? useLayoutEffect : useEffect;

export default useIsomorphicLayoutEffect;


###### frontend\src\shared\lib\hooks\use_media_query.ts
import { useState } from "react";

import useIsomorphicLayoutEffect from "./use_isomorphic_layout";

type UseMediaQueryOptions = {
  defaultValue?: boolean;
  initializeWithValue?: boolean;
};

const IS_SERVER = typeof window === "undefined";

export function useMediaQuery(
  query: string,
  {
    defaultValue = false,
    initializeWithValue = true,
  }: UseMediaQueryOptions = {}
): boolean {
  const getMatches = (query: string): boolean => {
    if (IS_SERVER) {
      return defaultValue;
    }
    return window.matchMedia(query).matches;
  };

  const [matches, setMatches] = useState<boolean>(() => {
    if (initializeWithValue) {
      return getMatches(query);
    }
    return defaultValue;
  });

  // Handles the change event of the media query.
  function handleChange() {
    setMatches(getMatches(query));
  }

  useIsomorphicLayoutEffect(() => {
    const matchMedia = window.matchMedia(query);

    // Triggered at the first client-side load and if query changes
    handleChange();

    // Use deprecated `addListener` and `removeListener` to support Safari < 14 (#135)
    if (matchMedia.addListener) {
      matchMedia.addListener(handleChange);
    } else {
      matchMedia.addEventListener("change", handleChange);
    }

    return () => {
      if (matchMedia.removeListener) {
        matchMedia.removeListener(handleChange);
      } else {
        matchMedia.removeEventListener("change", handleChange);
      }
    };
  }, [query]);

  return matches;
}

export default useMediaQuery;


###### frontend\src\shared\lib\providers\index.ts
export * from './websocket_provider';


###### frontend\src\shared\lib\providers\websocket_provider.tsx
import {
  useEffect,
  PropsWithChildren,
  createContext,
  useRef,
  useContext,
  useState,
} from "react";

import config from "@/shared/config";
import { apiAuth } from "@/features/auth/model";
import { useRouter } from "next/navigation";

interface WebsocketProviderProps extends PropsWithChildren {}

interface IWSContext {
  send: (data: any) => void;
  onMessage: (data: any) => void;
  isConnected: boolean;
}

const WSContext = createContext<IWSContext | null>(null);

const WebsocketProvider = ({ children }: WebsocketProviderProps) => {
  const wsRef = useRef<WebSocket | null>(null);
  const { mutateAsync } = apiAuth.postAccessToken();
  const onMessageFuncRef = useRef<(data: any) => void>((data: any) => {});

  useEffect(() => {
    let ws: WebSocket;

    if (wsRef.current) {
      return;
    }

    mutateAsync().then((data) => {
      const { access_token } = data as { access_token: string };
      ws = new WebSocket(
        `${config.NEXT_PUBLIC_API_WS_URL}/api/messages/?access_token=${access_token}`
      );

      if (!ws) {
        return;
      }

      wsRef.current = ws;

      ws.onopen = () => {
        console.log("connect");
      };

      ws.onmessage = (event) => {
        onMessageFuncRef.current(JSON.parse(event.data));
      };

      ws.onclose = () => {
        console.log("disconnect");
      };
    });

    return () => {
      if (!ws) {
        return;
      }

      ws.close();
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
        console.log("WebSocket closed");
      }
    };
  }, []);

  const send = (data: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
    } else {
      console.warn("websocket not open");
    }
  };

  const onMessage = (callback: (data: any) => void) => {
    // add listener on message,
    // use in your component in useEffect
    onMessageFuncRef.current = callback;
  };

  return (
    <WSContext.Provider
      value={{
        send,
        onMessage,
        isConnected: wsRef.current?.readyState === WebSocket.OPEN,
      }}
    >
      {children}
    </WSContext.Provider>
  );
};

export const useWS = () => {
  const context = useContext(WSContext);

  if (!context) {
    throw new Error("ws provider is not found");
  }

  return context;
};

export default WebsocketProvider;


###### frontend\src\shared\ui\button\button.module.scss
.button,
.invert_button {
  height: 40px;
  width: 250px;
  border-radius: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-decoration: none;
  font-weight: 500;
  letter-spacing: 0.5px;
}

.button:hover,
.invert_button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.button:active,
.invert_button:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.button:focus,
.invert_button:focus {
  outline: none;
  box-shadow: 0 0 0 3px var(--second);
}

.button:hover {
  background-color: var(--primary-light);
}

.button {
  border: none;
  background-color: var(--primary);
  color: var(--primary-foreground);
}

.invert_button {
  background-color: var(--primary-foreground);
  color: var(--primary);
  stroke: 1px solid var(--primary-background);
}


###### frontend\src\shared\ui\button\button.tsx
import { ButtonHTMLAttributes, forwardRef } from "react";
import clsx from "clsx";

import styles from "./button.module.scss";

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  styleType?: "default" | "invert";
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ children, className, styleType = "default", ...props }, ref) => {
    return (
      <button
        ref={ref}
        {...props}
        className={clsx(
          styleType == "invert" ? styles.invert_button : styles.button,
          className
        )}
      >
        {children}
      </button>
    );
  }
);

export default Button;


###### frontend\src\shared\ui\button\index.ts
export { default } from './button';

###### frontend\src\shared\ui\container\container.module.scss
.container {
  padding: 3vh 2vw 0px;
  background-color: var(--primary-background);
  height: 100%;
  overflow-y: hidden;

  @media (max-width: 1024px) {
    padding-top: 1.5vh;
  }
}


###### frontend\src\shared\ui\container\container.tsx
import { HTMLAttributes } from 'react';
import clsx from 'clsx';

import styles from './container.module.scss';

export interface ContainerProps extends HTMLAttributes<HTMLDivElement> {}

export const Container = ({ className, children }: ContainerProps) => {
  return <div className={clsx(styles.container, className)}>{children}</div>;
};

export default Container;


###### frontend\src\shared\ui\container\index.ts
export { default } from './container';
export type { ContainerProps } from './container';


###### frontend\src\shared\ui\form_page\form_page.module.scss
.form_layout {
  background-color: var(--primary-foreground);
  width: 100%;
  height: 100%;
  border-radius: 15px 15px 0 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.title {
  font-size: 32px;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.form_block {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 5vw;

  @media (max-width: 768px) {
    flex-direction: column;
  }
}


###### frontend\src\shared\ui\form_page\form_page.tsx
'use client';
import { FormEvent, FormEventHandler, HTMLAttributes, ReactNode } from 'react';

import styles from './form_page.module.scss';
import InputText from '@/shared/ui/inputs/input_text';
import type { InputTextProps } from '@/shared/ui/inputs/input_text';
import Button from '@/shared/ui/button';
import Container from '../container';

export interface FormPageProps extends HTMLAttributes<HTMLDivElement> {
  title: string;
}

export const FormPage = ({ title, children }: FormPageProps) => {
  // use for page being form
  return (
    <Container className={styles.container}>
      <div className={styles.form_layout}>
        <div className={styles.form_block}>
          <div className={styles.title}>{title}</div>
          {children}
        </div>
      </div>
    </Container>
  );
};

export default FormPage;


###### frontend\src\shared\ui\form_page\index.ts
export { default } from './form_page';
export type { FormPageProps } from './form_page';


###### frontend\src\shared\ui\image_uploader\image_uploader.module.scss
.wrapper {
  width: 100%;
  max-width: 28rem;
}

.header {
  text-align: center;
  margin-bottom: 2rem;
}

.title {
  font-size: 1.875rem;
  font-weight: 300;
  letter-spacing: -0.025em;
  margin-bottom: 0.5rem;
}

.formContainer {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.dropzone {
  position: relative;
  border-radius: 0.5rem;
  padding: 2rem;
  text-align: center;
  cursor: pointer;
  border: 2px dashed #000;
  transition: all 0.3s ease;
}

.dropzoneActive {
  background-color: rgba(0, 0, 0, 0.05);
}

.fileInput {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  cursor: pointer;
}

.dropzoneContent {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.iconContainer {
  display: flex;
  justify-content: center;
}

.icon {
  width: 2.5rem;
  height: 2.5rem;
}

.dropzoneTitle {
  font-weight: 500;
}

.dropzoneSubtitle {
  font-size: 0.875rem;
  color: #6b7280;
}

.previewContainer {
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 1rem;
}

.previewHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.previewTitle {
  font-weight: 500;
}

.clearButton {
  font-size: 0.875rem;
  text-decoration: underline;
  background: none;
  border: none;
  cursor: pointer;
}

.imageContainer {
  display: flex;
  justify-content: center;
}

.previewImage {
  max-height: 12rem;
  object-fit: contain;
  border-radius: 0.25rem;
}

.actionContainer {
  padding-top: 0.5rem;
}

.uploadButton {
  width: 100% !important;
  cursor: pointer;
}


###### frontend\src\shared\ui\image_uploader\image_uploader.tsx
"use client";
import { HTMLAttributes, useState } from "react";

import styles from "./image_uploader.module.scss";
import { IconCloudUpload } from "@tabler/icons-react";
import Button from "../button";

export interface ImageUploaderProps extends HTMLAttributes<HTMLDivElement> {
  title: string;
  uploadCallback: (file: File) => void;
}

export const ImageUploader = ({
  title,
  uploadCallback,
}: ImageUploaderProps) => {
  const [file, setFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string>("");
  const [isDragActive, setIsDragActive] = useState(false);

  // Handle file selection
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (selectedFile && selectedFile.type.match("image.*")) {
      setFile(selectedFile);
      const reader = new FileReader();
      reader.onload = () => {
        setPreviewUrl(reader.result as string);
      };
      reader.readAsDataURL(selectedFile);
    }
  };

  // Clear selected file
  const clearSelection = () => {
    setFile(null);
    setPreviewUrl("");
  };

  // Handle form submission
  const handleSubmit = (e: React.MouseEvent) => {
    e.preventDefault();
    if (!file) {
      alert("Пожалуйста, выберите изображение для загрузки.");
      return;
    }

    // Here you would normally send the file to a server
    uploadCallback(file);
    clearSelection();
  };

  // Handle drag events
  const handleDragEnter = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(false);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(true);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(false);

    const dt = e.dataTransfer;
    const files = dt.files;

    if (files.length) {
      const droppedFile = files[0];
      if (droppedFile.type.match("image.*")) {
        setFile(droppedFile);
        const reader = new FileReader();
        reader.onload = () => {
          setPreviewUrl(reader.result as string);
        };
        reader.readAsDataURL(droppedFile);
      }
    }
  };

  return (
    <div className={styles.wrapper}>
      <div className={styles.header}>
        <h1 className={styles.title}>{title}</h1>
      </div>

      <div className={styles.formContainer}>
        <div
          className={`${styles.dropzone} ${isDragActive ? styles.dropzoneActive : ""}`}
          onDragEnter={handleDragEnter}
          onDragLeave={handleDragLeave}
          onDragOver={handleDragOver}
          onDrop={handleDrop}
        >
          <input
            type="file"
            className={styles.fileInput}
            accept="image/*"
            onChange={handleFileChange}
          />
          <div className={styles.dropzoneContent}>
            <div className={styles.iconContainer}>
              <IconCloudUpload size={50} strokeWidth={1} />
            </div>
            <h3 className={styles.dropzoneTitle}>Перетащите файлы сюда</h3>
            <p className={styles.dropzoneSubtitle}>или нажмите для выбора</p>
          </div>
        </div>

        {previewUrl && (
          <div className={styles.previewContainer}>
            <div className={styles.previewHeader}>
              <h3 className={styles.previewTitle}>Выбранное изображение</h3>
              <button
                type="button"
                className={styles.clearButton}
                onClick={clearSelection}
              >
                Очистить
              </button>
            </div>
            <div className={styles.imageContainer}>
              <img
                src={previewUrl}
                alt="Preview"
                className={styles.previewImage}
              />
            </div>
          </div>
        )}

        <div className={styles.actionContainer}>
          <Button onClick={handleSubmit} className={styles.uploadButton}>
            Загрузить изображение
          </Button>
        </div>
      </div>
    </div>
  );
};

export default ImageUploader;


###### frontend\src\shared\ui\image_uploader\index.ts
import ImageUploader from './image_uploader';

export default ImageUploader;
export type { ImageUploaderProps } from './image_uploader';

###### frontend\src\shared\ui\inputs\input_text\index.ts
export { default } from './input_text';
export type { InputTextProps } from './input_text';


###### frontend\src\shared\ui\inputs\input_text\input_text.module.scss
.input {
  display: flex;
  flex-direction: column;
}

.input_text {
  text-align: left;
  font-size: 16px;
  margin-top: 5px;
  border: 2px solid var(--primary-background);
  width: 250px;
  height: 40px;
  border-radius: 10px;
  padding-left: 15px;

  outline-color: var(--primary-light);
  outline-width: 0.5px;
}


###### frontend\src\shared\ui\inputs\input_text\input_text.tsx
import { InputHTMLAttributes, RefObject, forwardRef } from "react";
import clsx from "clsx";

import styles from "./input_text.module.scss";

export interface InputTextProps extends InputHTMLAttributes<HTMLInputElement> {
  labelText?: string;
  placeholder: string;
  name: string;
  type?: string;
  classNameInput?: string;
  ref?: RefObject<HTMLInputElement>;
}

export const InputText = forwardRef<HTMLInputElement, InputTextProps>(
  (
    {
      labelText,
      placeholder,
      classNameInput,
      className,
      name,
      type,
      onKeyDown,
      ...props
    },
    ref
  ) => {
    return (
      <div className={clsx(styles.input, className)}>
        {labelText && <label>{labelText}</label>}
        <input
          {...props}
          ref={ref}
          type={type}
          name={name}
          className={clsx(styles.input_text, classNameInput)}
          placeholder={placeholder}
          onKeyDown={onKeyDown}
        />
      </div>
    );
  }
);

export default InputText;


###### frontend\src\shared\ui\inputs\textarea\index.ts
import Textarea from './textarea';

export default Textarea;
export type { TextareaProps } from './textarea';

###### frontend\src\shared\ui\inputs\textarea\textarea.module.scss
.textarea {
    display: flex;
    flex-direction: column;
}

.textarea_input {
    text-align: left;
    font-size: 16px;
    margin-top: 5px;
    border: 2px solid var(--primary-background);
    width: 250px;
    height: 40px;
    border-radius: 10px;
    padding: 0px 15px;
}


###### frontend\src\shared\ui\inputs\textarea\textarea.tsx
import { forwardRef, RefObject, TextareaHTMLAttributes } from 'react';
import clsx from 'clsx';

import styles from './textarea.module.scss';

export interface TextareaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {
  labelText?: string;
  placeholder: string;
  name: string;
  classNameInput?: string;
  ref?: RefObject<HTMLTextAreaElement>;
}

export const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ labelText, placeholder, classNameInput, className, name, onKeyDown }, ref) => {
    return (
      <div className={clsx(styles.textarea, className)}>
        {labelText && <label>{labelText}</label>}
        <textarea
          ref={ref}
          name={name}
          className={clsx(styles.textarea_input, classNameInput)}
          placeholder={placeholder}
          onKeyDown={onKeyDown}
        />
      </div>
    );
  },
);
export default Textarea;


###### frontend\src\shared\ui\navigation_mobile_layout\index.ts
import NavigationMobileLayout from './navigation_mobile_layout';

export default NavigationMobileLayout;
export type { NavigationMobileLayoutProps } from './navigation_mobile_layout';

###### frontend\src\shared\ui\navigation_mobile_layout\navigation_mobile_layout.module.scss
.navigation_mobile_layout {
  border-radius: 15px;
  width: 100%;
  background-color: var(--primary-foreground);
  height: 50px;
}


###### frontend\src\shared\ui\navigation_mobile_layout\navigation_mobile_layout.tsx
import { HTMLAttributes } from "react";

import styles from "./navigation_mobile_layout.module.scss";
import clsx from "clsx";

export interface NavigationMobileLayoutProps
  extends HTMLAttributes<HTMLDivElement> {}

export const NavigationMobileLayout = ({
  className,
  children,
}: NavigationMobileLayoutProps) => {
  return (
    <div className={clsx(styles.navigation_mobile_layout, className)}>
      {children}
    </div>
  );
};

export default NavigationMobileLayout;


###### frontend\src\shared\ui\vertical_line\index.ts
export { default } from './vertical_line';
export type { VerticalLineProps } from './vertical_line';

###### frontend\src\shared\ui\vertical_line\vertical_line.module.scss
.vertical_line {
    width: 1.5px;
    height: 80%;
    background-color: var(--primary-background);
}


###### frontend\src\shared\ui\vertical_line\vertical_line.tsx
import { HTMLAttributes } from 'react';
import clsx from 'clsx';
import styles from './vertical_line.module.scss';

export interface VerticalLineProps extends HTMLAttributes<HTMLDivElement> {}

export const VerticalLine = ({ className }: VerticalLineProps) => {
  return <div className={clsx(styles.vertical_line, className)} />;
};

export default VerticalLine;


###### frontend\src\widgets\mobile_navigation\ui\index.ts
import NavigationMobile from './navigation_mobile';

export default NavigationMobile;
export type { NavigationMobileProps } from './navigation_mobile';

###### frontend\src\widgets\mobile_navigation\ui\navigation_mobile.module.scss
.navigation_mobile {
  border-radius: 15px;
  width: 100%;
  background-color: var(--primary-foreground);
  height: 50px;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 25px;
}

.navigation_item {
  cursor: pointer;
}


###### frontend\src\widgets\mobile_navigation\ui\navigation_mobile.tsx
import { HTMLAttributes } from "react";

import styles from "./navigation_mobile.module.scss";
import { IconBurger } from "@tabler/icons-react";
import UserDropdown from "@/widgets/navigation/ui/user_dropdown";
import UserCard from "@/entities/user/ui";
import Link from "next/link";
import Image from "next/image";
import clsx from "clsx";

export interface NavigationMobileProps extends HTMLAttributes<HTMLDivElement> {}

export const NavigationMobile = ({
  children,
  className,
  ...props
}: NavigationMobileProps) => {
  // the panel on the top of window for mobile with additional logic
  return (
    <div {...props} className={clsx(styles.navigation_mobile, className)}>
      {children}
      <UserDropdown>
        <UserCard styleType="small" />
      </UserDropdown>
      <Link
        className={styles.navigation_item}
        href="/communication/create_group"
      >
        <Image
          src="/icons/category-plus.svg"
          width={35}
          height={35}
          alt="add group"
          className={styles.add_group}
        />
      </Link>
    </div>
  );
};

export default NavigationMobile;


###### frontend\src\widgets\navigation\ui\index.ts
import Navigation from "./navigation";

export default Navigation;
export type { NavigationProps } from "./navigation";


###### frontend\src\widgets\navigation\ui\navigation.module.scss
.navigation {
  width: 80px;
  height: 100%;
  background-color: var(--primary-foreground);
  display: flex;
  flex-direction: column;
  align-items: center;
  border-radius: 15px 15px 0 0;
  padding-top: 20px;
  gap: 25px;
}

.navigation_item {
  cursor: pointer;
}


###### frontend\src\widgets\navigation\ui\navigation.tsx
import { HTMLAttributes } from "react";
import Image from "next/image";
import Link from "next/link";

import UserCard from "@/entities/user/ui";
import styles from "./navigation.module.scss";
import UserDropdown from "./user_dropdown";
import clsx from "clsx";

export interface NavigationProps extends HTMLAttributes<HTMLDivElement> {}

export const Navigation = ({ className }: NavigationProps) => {
  // a panel on the left of window
  return (
    <div className={clsx(styles.navigation, className)}>
      <UserDropdown>
        <UserCard />
      </UserDropdown>
      <Link
        className={styles.navigation_item}
        href="/communication/create_group"
      >
        <Image
          src="/icons/category-plus.svg"
          width={35}
          height={35}
          alt="add group"
          className={styles.add_group}
        />
      </Link>
    </div>
  );
};

export default Navigation;


###### frontend\src\widgets\navigation\ui\user_dropdown\index.ts
import UserDropdown from './user_dropdown';

export default UserDropdown;
export type { UserDropdownProps } from './user_dropdown';

###### frontend\src\widgets\navigation\ui\user_dropdown\user_dropdown.module.scss
.dropdown {
  position: relative;
  display: inline-block;
  cursor: pointer;
}

.menu_content {
  background-color: white;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 8px;
  box-shadow: 0px 4px 16px rgba(0, 0, 0, 0.1);
  min-width: 180px;
  z-index: 1000;
}

.menu_item {
  padding: 8px 12px;
  font-size: 14px;
  color: #1a202c;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.2s ease;
}

.menu_item:hover {
  background-color: #f1f5f9;
}

.menu_separator {
  height: 1px;
  background-color: #e2e8f0;
  margin: 6px 0;
}

.sub_content {
  background-color: white;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 8px;
  box-shadow: 0px 4px 16px rgba(0, 0, 0, 0.1);
}

.sub_trigger {
  padding: 8px 12px;
  font-size: 14px;
  color: #1a202c;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.sub_trigger:hover {
  background-color: #f1f5f9;
}


###### frontend\src\widgets\navigation\ui\user_dropdown\user_dropdown.tsx
import { HTMLAttributes } from "react";
import * as DropdownMenu from "@radix-ui/react-dropdown-menu";
import clsx from "clsx";

import styles from "./user_dropdown.module.scss";
import { apiAuth } from "@/features/auth/model";
import { useRouter } from "next/navigation";

export interface UserDropdownProps extends HTMLAttributes<HTMLDivElement> {}

export const UserDropdown = ({ children, className }: UserDropdownProps) => {
  const { mutate } = apiAuth.logout();
  const router = useRouter();

  const onClick = () => {
    mutate();
    router.push("/");
  };

  return (
    <div className={clsx(styles.dropdown, className)}>
      <DropdownMenu.Root>
        <DropdownMenu.Trigger asChild>{children}</DropdownMenu.Trigger>
        <DropdownMenu.Portal>
          <DropdownMenu.Content className={styles.menu_content}>
            <DropdownMenu.Item className={styles.menu_item} onClick={onClick}>
              Выйти из аккаунта
            </DropdownMenu.Item>
          </DropdownMenu.Content>
        </DropdownMenu.Portal>
      </DropdownMenu.Root>
    </div>
  );
};

export default UserDropdown;


###### frontend\src\_pages\communication\ui\communication.module.scss
.communication {
  flex: 1;
  background-color: var(--primary-foreground);
  border-radius: 15px 15px 0 0;
  height: 100%;
  padding: 2vh 1.5vw 0px 1.5vw;
  display: flex;
  flex-direction: row;
  justify-content: center;
  margin-left: 20px;

  @media (max-width: 768px) {
    margin-left: 0;
    padding-left: 4vw;
    padding-right: 4vw;
  }
}

.groups {
  margin-top: 40px;
}

.container {
  display: flex;
  flex-direction: row;

  @media (max-width: 768px) {
    flex-direction: column;
  }
}

.current_group {
  flex: 1;
  display: flex;
  justify-content: center;
}

.channels {
  max-width: 300px;
  padding-right: 1.5vw;

  @media (max-width: 1024px) {
    padding-right: 4vw;
  }

  @media (max-width: 768px) {
    padding-right: 0;
    width: 100%;
  }
}

.nav_mobile {
  margin-bottom: 10px;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 0 15px;
  flex-shrink: 0;

  @media (min-width: 768px) {
    display: none !important;
  }
}

.nav {
  @media (max-width: 768px) {
    display: none !important;
  }
}

.vertical_line {
  display: none;

  @media (min-width: 768px) {
    display: block !important;
  }
}

.nav_icon {
  width: 30px;
  height: 30px;
}


###### frontend\src\_pages\communication\ui\communication.tsx
"use client";
import { HTMLAttributes, useEffect } from "react";

import styles from "./communication.module.scss";
import Container from "@/shared/ui/container";
import GroupList from "@/_pages/communication/ui/group_list";
import SearchInput from "./search_input";
import Navigation from "@/widgets/navigation/ui";
import CurrentGroup from "./current_group";
import VerticalLine from "@/shared/ui/vertical_line";
import { apiAuth } from "@/features/auth/model";
import { useRouter } from "next/navigation";
import useMediaQuery from "@/shared/lib/hooks/use_media_query";
import { useAppDispatch, useAppSelector } from "@/shared/lib/hooks";
import NavigationMobileLayout from "@/shared/ui/navigation_mobile_layout";
import { IconArrowBackUp, IconBurger } from "@tabler/icons-react";
import { setChatId } from "@/entities/chat/model/slice";
import { setGroupData } from "@/entities/group/model/slice";
import clsx from "clsx";
import NavigationMobile from "@/widgets/mobile_navigation/ui";

export interface CommunicationProps extends HTMLAttributes<HTMLDivElement> {}

export const Communication = ({}: CommunicationProps) => {
  const isTablet = useMediaQuery("(min-width: 768px)", {
    initializeWithValue: false,
  });
  const groupId = useAppSelector((state) => state.group.id);

  const dispatch = useAppDispatch();
  const router = useRouter();

  const onChatBack = () => {
    dispatch(setChatId(null));
    dispatch(setGroupData({ id: null, title: null }));
  };

  const chatBack = (
    <IconArrowBackUp className={styles.nav_icon} onClick={onChatBack} />
  );

  return (
    <Container className={styles.container}>
      <NavigationMobile className={styles.nav_mobile}>
        {groupId && chatBack}
      </NavigationMobile>
      <Navigation className={styles.nav} />
      <div className={styles.communication}>
        {((!groupId && !isTablet) || isTablet) && (
          <div className={styles.channels}>
            <SearchInput />
            <GroupList className={styles.groups} />
          </div>
        )}

        {(isTablet || (groupId && !isTablet)) && (
          <>
            {/* vertical line for laptop and more */}
            <VerticalLine className={styles.vertical_line} />
            <CurrentGroup className={styles.current_group} />
          </>
        )}
      </div>
    </Container>
  );
};

export default Communication;


###### frontend\src\_pages\communication\ui\index.ts
import Communication from './communication';

export default Communication;
export type { CommunicationProps } from './communication';


###### frontend\src\_pages\communication\ui\chat_list\chat_list.module.scss
.chat_list {
  display: flex;
  flex-direction: column;
  gap: 20px;

  overflow-y: auto;
  scrollbar-width: thin;

  .chat_item {
    font-size: 16px;
    font-weight: 800;
  }
}


###### frontend\src\_pages\communication\ui\chat_list\chat_list.tsx
import { HTMLAttributes } from "react";
import clsx from "clsx";

import styles from "./chat_list.module.scss";
import { useApiChat, ReadChatSchema } from "@/entities/chat/model";
import { useAppSelector } from "@/shared/lib/hooks";
import Chat from "@/entities/chat/ui";
import { useAppDispatch } from "@/shared/lib/hooks";
import { setChatId } from "@/entities/chat/model/slice";

export interface ChatListProps extends HTMLAttributes<HTMLDivElement> {}

export const ChatList = ({ className }: ChatListProps) => {
  const dispatch = useAppDispatch();
  const groupId = useAppSelector((state) => state.group.id);

  // if groupId is null, then dont render
  if (!groupId) {
    return null;
  }

  const { data }: { data: ReadChatSchema[] | undefined } =
    useApiChat.getGroupChats({
      groupId: groupId,
    });

  return (
    <div className={clsx(className, styles.chat_list)}>
      {data?.map((item) => (
        <Chat
          className={styles.chat_item}
          key={item.id}
          title={item.title}
          onClick={() => dispatch(setChatId(item.id))}
        />
      ))}
    </div>
  );
};

export default ChatList;


###### frontend\src\_pages\communication\ui\chat_list\index.ts
import ChatList from './chat_list';

export default ChatList;
export type { ChatListProps } from './chat_list';

###### frontend\src\_pages\communication\ui\chat_list\ui\index.ts
import ChatList from "../chat_list";

export default ChatList;
export type { ChatListProps } from "../chat_list";


###### frontend\src\_pages\communication\ui\current_group\current_group.module.scss
.current_group {
  display: flex;
  flex-direction: row;
}

.current_group_unselect {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 16px;
  font-weight: 600;
}

.group_panel {
  margin-left: 40px;

  @media (max-width: 768px) {
    margin-left: 0;
  }
}

.vertical_line {
  display: none;

  @media (min-width: 1024px) {
    display: block;
  }
}

.talk {
  flex: 1;
}


###### frontend\src\_pages\communication\ui\current_group\current_group.tsx
"use client";
import { HTMLAttributes } from "react";
import clsx from "clsx";

import styles from "./current_group.module.scss";
import VerticalLine from "@/shared/ui/vertical_line";
import Talk from "../talk";
import GroupPanel from "../group_panel";
import { useAppSelector } from "@/shared/lib/hooks";
import useMediaQuery from "@/shared/lib/hooks/use_media_query";

export interface CurrentGroupProps extends HTMLAttributes<HTMLDivElement> {}

export const CurrentGroup = ({ className }: CurrentGroupProps) => {
  const groupId = useAppSelector((state) => state.group.id);

  return (
    <div className={clsx(styles.current_group, className)}>
      {groupId ? (
        <>
          <Talk className={styles.talk} />
          <VerticalLine className={styles.vertical_line} />
          <GroupPanel className={styles.group_panel} />
        </>
      ) : (
        <div className={styles.current_group_unselect}>Выберите группу</div>
      )}
    </div>
  );
};

export default CurrentGroup;


###### frontend\src\_pages\communication\ui\current_group\index.ts
export { default } from './current_group';
export type { CurrentGroupProps } from './current_group';

###### frontend\src\_pages\communication\ui\dialog_create_chat\dialog_create_chat.module.scss
.dialog_root {
}

.dialog_content_layout {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  position: fixed;
  background-color: rgba($color: var(--primary-background), $alpha: 0.5);
}

.dialog_content {
  width: 450px;
  margin: auto;
  background-color: var(--primary-foreground);
  border: 2px solid var(--primary-background);
  padding: 40px;
  border-radius: 10px;
}

.input {
  margin-top: 20px;
  width: 100%;
}

.input_field {
  width: 100% !important;
}

.button {
  width: 100px !important;
  cursor: pointer;
}

.close {
  transform: rotate(45deg);
}

.title {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

.buttons {
  display: flex;
  flex-direction: row;
  justify-content: end;
  gap: 15px;
  margin-top: 15px;
}

.title_icon {
  transform: rotate(45deg);
}


###### frontend\src\_pages\communication\ui\dialog_create_chat\dialog_create_chat.tsx
import { HTMLAttributes, MouseEventHandler, useRef, useState } from "react";
import { IconPlus } from "@tabler/icons-react";
import * as Dialog from "@radix-ui/react-dialog";

import styles from "./dialog_create_chat.module.scss";
import InputText from "@/shared/ui/inputs/input_text";
import Button from "@/shared/ui/button";

export interface DialogCreateChatProps extends HTMLAttributes<HTMLDivElement> {
  onClickHandler: (value: string) => void;
}

const DialogCreateChat = ({
  children,
  onClickHandler,
}: DialogCreateChatProps) => {
  const inputValueRef = useRef<HTMLInputElement>(null);

  const onClick: MouseEventHandler<HTMLButtonElement> = (e) => {
    if (!inputValueRef.current?.value) {
      return;
    }

    onClickHandler(inputValueRef.current.value);
  };

  return (
    <div className={styles.dialog_root}>
      <Dialog.Root>
        <Dialog.Trigger asChild={true}>{children}</Dialog.Trigger>

        <div className={styles.dialog_content_layout}>
          <Dialog.Content className={styles.dialog_content}>
            <div className={styles.title}>
              <Dialog.Title className={styles.title_text}>
                Создание чата
              </Dialog.Title>
              <Dialog.Close asChild={true}>
                <div className="icon_box">
                  <IconPlus className={styles.title_icon} />
                </div>
              </Dialog.Close>
            </div>
            <Dialog.Description />
            <InputText
              ref={inputValueRef}
              classNameInput={styles.input}
              className={styles.input_field}
              placeholder="Введите название..."
              name="chat"
            />
            <div className={styles.buttons}>
              <Dialog.Close asChild={true}>
                <Button className={styles.button} styleType="invert">
                  Отмена
                </Button>
              </Dialog.Close>
              <Dialog.Close asChild={true}>
                <Button onClick={onClick} className={styles.button}>
                  Создать
                </Button>
              </Dialog.Close>
            </div>
          </Dialog.Content>
        </div>
      </Dialog.Root>
    </div>
  );
};

export default DialogCreateChat;


###### frontend\src\_pages\communication\ui\dialog_create_chat\index.ts
import DialogCreateChat from './dialog_create_chat';

export default DialogCreateChat;
export type { DialogCreateChatProps } from './dialog_create_chat';

###### frontend\src\_pages\communication\ui\dialog_invitation\dialog_invitation.module.scss
.dialog_root {
}

.dialog_content_layout {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  position: fixed;
  background-color: rgba($color: var(--primary-background), $alpha: 0.5);
}

.dialog_content {
  width: 450px;
  margin: auto;
  background-color: var(--primary-foreground);
  border: 2px solid var(--primary-background);
  padding: 40px;
  border-radius: 10px;
}

.input {
  margin-top: 20px;
  width: 100%;
}

.button {
  width: 100px !important;
}

.close {
  transform: rotate(45deg);
}

.title {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

.buttons {
  display: flex;
  flex-direction: row;
  justify-content: end;
  gap: 15px;
  margin-top: 15px;
}

.title_icon {
  transform: rotate(45deg);
}


###### frontend\src\_pages\communication\ui\dialog_invitation\dialog_invitation.tsx
import { HTMLAttributes, use, useEffect } from "react";
import { IconPlus, IconCopy } from "@tabler/icons-react";
import * as Dialog from "@radix-ui/react-dialog";

import styles from "./dialog_invitation.module.scss";
import InputText from "@/shared/ui/inputs/input_text";
import Button from "@/shared/ui/button";
import { useApiGroup } from "@/entities/group/model";
import { useAppSelector } from "@/shared/lib/hooks";
import settings from "@/shared/config";

export interface DialogInvitationProps extends HTMLAttributes<HTMLDivElement> {
  open: boolean;
  setOpen: (open: boolean) => void;
}

const DialogInvitation = ({
  children,
  open,
  setOpen,
}: DialogInvitationProps) => {
  if (!open) return null;

  const groupId = useAppSelector((state) => state.group.id);
  var {
    data: inivitationToken,
    isLoading,
  }: { data: string | undefined; isLoading: boolean } =
    useApiGroup.getInviteToken({ groupId: groupId! }, undefined, {
      enabled: !!groupId,
    });

  if (!inivitationToken && !isLoading) {
    return alert("Произошла ошибка, попробуйте обновить страницу");
  }

  const inviteLink = `${settings.NEXT_PUBLIC_FRONTEND_URL}/communication/join_group/${inivitationToken}`;

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(inviteLink);
    } catch (err) {
      console.error("Ошибка копирования:", err);
    }
  };

  return (
    <div className={styles.dialog_root}>
      <Dialog.Root open={open} onOpenChange={setOpen}>
        <Dialog.Portal>
          <Dialog.Overlay className={styles.dialog_overlay} />

          <div className={styles.dialog_content_layout}>
            <Dialog.Content className={styles.dialog_content}>
              <div className={styles.title}>
                <Dialog.Title className={styles.title_text}>
                  Пригласить участника
                </Dialog.Title>
                <Dialog.Close asChild>
                  <div className="icon_box">
                    <IconPlus className={styles.title_icon} />
                  </div>
                </Dialog.Close>
              </div>

              <InputText
                placeholder=""
                classNameInput={styles.input}
                value={inviteLink}
                name="invite"
                readOnly
              />

              <div className={styles.buttons}>
                <Dialog.Close asChild>
                  <Button className={styles.button} styleType="invert">
                    Отмена
                  </Button>
                </Dialog.Close>
                <Dialog.Close asChild>
                  <Button onClick={handleCopy} className={styles.button}>
                    Копировать
                  </Button>
                </Dialog.Close>
              </div>
            </Dialog.Content>
          </div>
        </Dialog.Portal>
      </Dialog.Root>
    </div>
  );
};

export default DialogInvitation;


###### frontend\src\_pages\communication\ui\dialog_invitation\index.ts
import DialogInvitation from './dialog_invitation';

export default DialogInvitation;
export type { DialogInvitationProps } from './dialog_invitation';

###### frontend\src\_pages\communication\ui\group_dropdown\group_dropdown.module.scss
.dropdown {
  position: relative;
  display: inline-block;
}

.menu_content {
  background-color: white;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 8px;
  box-shadow: 0px 4px 16px rgba(0, 0, 0, 0.1);
  min-width: 180px;
  z-index: 1000;
}

.menu_item {
  padding: 8px 12px;
  font-size: 14px;
  color: #1a202c;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.2s ease;
}

.menu_item:hover {
  background-color: #f1f5f9;
}

.menu_separator {
  height: 1px;
  background-color: #e2e8f0;
  margin: 6px 0;
}

.sub_content {
  background-color: white;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 8px;
  box-shadow: 0px 4px 16px rgba(0, 0, 0, 0.1);
}

.sub_trigger {
  padding: 8px 12px;
  font-size: 14px;
  color: #1a202c;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.sub_trigger:hover {
  background-color: #f1f5f9;
}


###### frontend\src\_pages\communication\ui\group_dropdown\group_dropdown.tsx
"use client";
import { HTMLAttributes } from "react";
import clsx from "clsx";
import { useState } from "react";

import styles from "./group_dropdown.module.scss";
import * as DropdownMenu from "@radix-ui/react-dropdown-menu";
import Link from "next/link";
import DialogInvitation from "../dialog_invitation";

export interface GroupDropdownProps extends HTMLAttributes<HTMLDivElement> {}

export const GroupDropdown = ({ className, children }: GroupDropdownProps) => {
  // dropdown with logic for group
  const [openDialog, setOpenDialog] = useState(false);

  return (
    <div className={clsx(styles.dropdown, className)}>
      <DropdownMenu.Root>
        <DropdownMenu.Trigger asChild>{children}</DropdownMenu.Trigger>
        <DropdownMenu.Portal>
          <DropdownMenu.Content className={styles.menu_content}>
            <DropdownMenu.Item
              className={styles.menu_item}
              onSelect={() => setOpenDialog(true)}
            >
              Добавить участника
            </DropdownMenu.Item>

            <DropdownMenu.Item className={styles.menu_item}>
              <Link href={"/communication/settings"}>Настройки группы</Link>
            </DropdownMenu.Item>

            <DropdownMenu.Item className={styles.menu_item}>
              Выйти из группы
            </DropdownMenu.Item>
          </DropdownMenu.Content>
        </DropdownMenu.Portal>
      </DropdownMenu.Root>

      <DialogInvitation open={openDialog} setOpen={setOpenDialog} />
    </div>
  );
};

export default GroupDropdown;


###### frontend\src\_pages\communication\ui\group_dropdown\index.ts
import GroupDropdown from './group_dropdown';

export default GroupDropdown;
export type { GroupDropdownProps } from './group_dropdown';

###### frontend\src\_pages\communication\ui\group_list\group_list.module.scss
.groups {
    display: flex;
    flex-direction: column;
    gap: 25px;
}


###### frontend\src\_pages\communication\ui\group_list\group_list.tsx
"use client";
import { HTMLAttributes } from "react";
import clsx from "clsx";

import GroupCard from "@/entities/group/ui";
import styles from "./group_list.module.scss";
import { useAppDispatch, useAppSelector } from "@/shared/lib/hooks";
import { setGroupData } from "@/entities/group/model/slice";
import { useApiGroup, ReadGroupSchema } from "@/entities/group/model";
import { setChatId } from "@/entities/chat/model/slice";

export interface GroupListProps extends HTMLAttributes<HTMLDivElement> {}

export const GroupList = ({ className }: GroupListProps) => {
  const dispatch = useAppDispatch();
  const { data }: { data: ReadGroupSchema[] | undefined } =
    useApiGroup.getMyGroups();

  // filter group by name
  const searchQuery = useAppSelector((state) => state.group.search_query);

  const onClick = (id: string, title: string) => {
    dispatch(setGroupData({ id, title }));
    dispatch(setChatId(null));
  };

  const filteredData = searchQuery
    ? data?.filter((value) => value.title.includes(searchQuery))
    : data;

  return (
    <div className={clsx(styles.groups, className)}>
      {filteredData &&
        filteredData.map((item) => (
          <GroupCard
            key={item.title}
            id={item.id}
            onClick={() => onClick(item.id, item.title)}
            data={item}
          />
        ))}
    </div>
  );
};

export default GroupList;


###### frontend\src\_pages\communication\ui\group_list\index.ts
import GroupList from './group_list';

export type { GroupListProps } from './group_list';
export default GroupList;


###### frontend\src\_pages\communication\ui\group_panel\group_panel.module.scss
.group_panel {
  display: flex;
  flex-direction: column;
}

.panorama {
  width: 350px;
  height: 200px;
  border-radius: 20px;
  background-color: var(--primary-background);
  position: relative;
  display: flex;
  flex-direction: row;
  flex-shrink: 0;

  .panorama_image {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 20px;
  }

  .panorama_title {
    display: block;
    font-size: 16px;
    font-weight: 800;
    margin: auto auto 20px 20px;
    color: var(--primary-foreground);
    z-index: 1;
  }

  .panorama_dropdown {
    fill: red;
    cursor: pointer;
  }

  .panorama_options {
    display: block;
    z-index: 1;
  }

  .panorama_gradient {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(
      0deg,
      rgba(186, 186, 186, 1) 0%,
      rgba(231, 231, 231, 0) 100%
    );
    border-radius: 0 0 20px 20px;
  }
}

.chat_title {
  margin: 40px 0 20px 0;
  display: flex;
  justify-content: space-between;

  span {
    font-size: 16px;
    font-weight: 800;
  }
}
.panorama_dropdown {
  z-index: 11;
  margin: auto 20px 20px auto;
}

.chat_list {
  margin-bottom: 60px;
}


###### frontend\src\_pages\communication\ui\group_panel\group_panel.tsx
import { HTMLAttributes, useEffect, useState } from "react";
import clsx from "clsx";
import { useQueryClient } from "@tanstack/react-query";
import Image from "next/image";
import { IconPlus } from "@tabler/icons-react";

import styles from "./group_panel.module.scss";
import { useAppSelector } from "@/shared/lib/hooks";
import ChatList from "../chat_list";
import GroupDropdown from "../group_dropdown";
import DialogCreateChat from "../dialog_create_chat";
import { useApiChat } from "@/entities/chat/model";
import useMediaQuery from "@/shared/lib/hooks/use_media_query";
import { useApiGroup } from "@/entities/group/model";

export interface GroupPanelProps extends HTMLAttributes<HTMLDivElement> {}

export const GroupPanel = ({ className }: GroupPanelProps) => {
  /*
  Group panel it is block with all connected with current group
  */
  const queryClient = useQueryClient();
  const groupId = useAppSelector((state) => state.group.id);
  const chatId = useAppSelector((state) => state.chat.id);
  const groupName = useAppSelector((state) => state.group.title);
  const panorama_path = useAppSelector((state) => state.group.panorama_path);
  const [panoramaUrl, setPanoramaUrl] = useState<string | null>(null);
  const { mutateAsync } = useApiChat.create();
  const isLaptop = useMediaQuery("(min-width: 1024px)");

  if (!groupId) {
    return;
  }

  useEffect(() => {
    if (!groupId || !panorama_path) {
      return;
    }

    const load = async () => {
      const result = await useApiGroup.loadPanorama(groupId);

      const url = URL.createObjectURL(result);
      setPanoramaUrl(url);
    };

    load();

    return () => {
      setPanoramaUrl(null);
    };
  }, [groupId]);

  const createChat = async (value: string) => {
    await mutateAsync({ groupId, requestBody: { title: value } });

    queryClient.invalidateQueries({
      queryKey: [useApiChat.getGroupChatsKey, { groupId: groupId }],
    });
  };

  if (isLaptop || (!chatId && !isLaptop)) {
    return (
      <div className={clsx(styles.group_panel, className)}>
        <div className={styles.panorama}>
          {panoramaUrl && (
            <Image
              src={panoramaUrl}
              width={300}
              height={200}
              alt="Panorama"
              className={styles.panorama_image}
            />
          )}
          <div className={styles.panorama_title}>{groupName}</div>
          <GroupDropdown className={styles.panorama_dropdown}>
            <Image
              className={styles.panorama_options}
              src="/icons/chevron-down.svg"
              width={25}
              height={25}
              alt="options"
            />
          </GroupDropdown>
          <div className={styles.panorama_gradient}></div>
        </div>

        <div className={styles.chat_title}>
          <span>Чаты</span>
          <DialogCreateChat
            onClickHandler={(value: string) => createChat(value)}
          >
            <div className="icon_box">
              <IconPlus size="25" className={styles.chat_create} />
            </div>
          </DialogCreateChat>
        </div>
        <ChatList className={styles.chat_list} />
      </div>
    );
  }
};

export default GroupPanel;


###### frontend\src\_pages\communication\ui\group_panel\index.ts
export { default } from './group_panel';
export type { GroupPanelProps } from './group_panel';

###### frontend\src\_pages\communication\ui\search_input\index.ts
export { default } from './search_input';
export type { SearchInputProps } from './search_input';

###### frontend\src\_pages\communication\ui\search_input\search_input.module.scss
.search_input {
  width: 100% !important;
  height: 40px !important;
}


###### frontend\src\_pages\communication\ui\search_input\search_input.tsx
import { ChangeEvent, HTMLAttributes, useState } from "react";

import InputText from "@/shared/ui/inputs/input_text";
import styles from "./search_input.module.scss";
import { useAppDispatch } from "@/shared/lib/hooks";
import { setSearchQuery } from "@/entities/group/model/slice";

export interface SearchInputProps extends HTMLAttributes<HTMLDivElement> {}

export const SearchInput = ({}: SearchInputProps) => {
  const dispatch = useAppDispatch();

  const onChange = (e: ChangeEvent<HTMLInputElement>) => {
    dispatch(setSearchQuery(e.target.value));
  };

  return (
    <InputText
      name="search"
      placeholder="Поиск..."
      classNameInput={styles.search_input}
      onChange={onChange}
    />
  );
};

export default SearchInput;


###### frontend\src\_pages\communication\ui\sending\index.ts
export { default } from './sending';
export type { SendingProps } from './sending';

###### frontend\src\_pages\communication\ui\sending\sending.module.scss
.sending_input {
  width: 100% !important;
  height: 55px !important;
}


###### frontend\src\_pages\communication\ui\sending\sending.tsx
import { HTMLAttributes, RefObject, forwardRef } from "react";

import styles from "./sending.module.scss";
import stylesInput from "@/shared/ui/inputs/input_text/input_text.module.scss";
import clsx from "clsx";

export interface SendingProps extends HTMLAttributes<HTMLInputElement> {}

export const Sending = forwardRef<HTMLInputElement, SendingProps>(
  ({ onKeyDown }, ref) => {
    return (
      <input
        ref={ref}
        name="send_message"
        placeholder="Введите сообщение..."
        className={clsx(stylesInput.input_text, styles.sending_input)}
        onKeyDown={onKeyDown}
      />
    );
  }
);

export default Sending;


###### frontend\src\_pages\communication\ui\talk\index.ts
export { default } from './talk';
export type { TalkProps } from './talk';

###### frontend\src\_pages\communication\ui\talk\talk.module.scss
.talk {
  display: flex;
  flex-direction: column;
  justify-content: end;
  align-items: center;
  padding: 30px 40px;

  @media (max-width: 1024px) {
    padding: 10px 10px;
  }
}

.current_chat_unselect {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  font-weight: 800;
}

.talk_content {
  position: relative;
  height: 100%;
  width: 42vw;

  @media (max-width: 768px) {
    width: 70vw;
  }
}

.top_gradient {
  width: 100%;
  height: 10px;
  top: 0;
  left: 0;
  position: absolute;
  background: linear-gradient(
    180deg,
    rgba(253, 253, 253, 0.9) 0%,
    rgba(253, 253, 253, 0) 100%
  );
}

.message_list {
  height: 90%;
  overflow-y: auto;
  scrollbar-width: thin;
  display: flex;
  flex-direction: column;
  gap: 25px;

  @media (max-width: 1024px) {
    overflow-y: hidden;
  }
}

.sending_container {
  position: relative;
}

.talk_unselect {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  font-weight: 800;
}


###### frontend\src\_pages\communication\ui\talk\talk.tsx
"use client";
import {
  HTMLAttributes,
  KeyboardEventHandler,
  useEffect,
  useReducer,
  useRef,
  useState,
} from "react";
import clsx from "clsx";

import styles from "./talk.module.scss";
import config from "@/shared/config";
import { useAppDispatch, useAppSelector } from "@/shared/lib/hooks";
import Sending from "../sending";
import Message from "@/entities/message/ui";
import { useApiMessage, ReadMessageSchema } from "@/entities/message/model";
import { useWS } from "@/shared/lib/providers";
import { useQueryClient } from "@tanstack/react-query";
import useMediaQuery from "@/shared/lib/hooks/use_media_query";

export interface TalkProps extends HTMLAttributes<HTMLDivElement> {}

export const Talk = ({ className }: TalkProps) => {
  const queryClient = useQueryClient();
  const chatId = useAppSelector((state) => state.chat.id);
  const sendMessageRef = useRef<HTMLInputElement>(null);
  const { send, onMessage } = useWS();
  const isLaptop = useMediaQuery("(min-width: 1024px)");
  const [toBottom, setToBottom] = useState(true);
  const messagesRef = useRef<HTMLDivElement>(null);

  const { data: messages }: { data: ReadMessageSchema[] | undefined } =
    useApiMessage.getAllMessageChat(
      {
        chatId: chatId!,
      },
      undefined,
      {
        enabled: !!chatId,
      }
    );

  const handleScroll = () => {
    // event when get new message we scroll to the end messages
    const messages = messagesRef.current;
    if (!messages) return;
    const { scrollTop, scrollHeight, clientHeight } = messages;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;

    if (distanceFromBottom >= 500) {
      return;
    }

    messages.scrollTo({
      top: messages.scrollHeight,
      behavior: "smooth",
    });
  };

  useEffect(() => {
    const messages = messagesRef.current;
    if (messages == null) {
      return;
    }

    if (toBottom == false) {
      handleScroll();
    } else {
      //scroll to bottom whem open page
      setToBottom(false);
      messages.scrollTo({
        top: messages.scrollHeight,
      });
    }

    //scroll to bottom if its need
  }, [messages]);

  // Пример изменения данных
  const updateMessage = (newMessage: ReadMessageSchema) => {
    // add new message to messages
    queryClient.setQueryData(
      [useApiMessage.getAllMessageChatKey, { chatId }],
      (oldData: ReadMessageSchema[] | undefined) => {
        return oldData ? [...oldData, newMessage] : [newMessage];
      }
    );
  };

  useEffect(() => {
    onMessage((message: any) => {
      if (typeof message.id == "undefined") {
        return;
      }

      updateMessage(message);
    });
    // maybe its need to fix
  }, [messages]);

  const sentMessage: KeyboardEventHandler = (e) => {
    if (e.key !== "Enter" || !sendMessageRef.current) {
      return;
    }

    //check lenght message
    const message = sendMessageRef.current.value;
    if (message.length > 2000) {
      alert("Сообщение не должно быть больше 2000 символов");
    }

    send({
      message,
      to_chat_id: chatId,
      is_group: true,
    });

    sendMessageRef.current.value = "";
  };

  if (messages) {
    return (
      <div className={clsx(styles.talk, className)}>
        <div className={styles.talk_content}>
          <div className={styles.top_gradient} />
          <div ref={messagesRef} className={clsx(styles.message_list)}>
            {messages.length != 0 &&
              messages.map((item) => (
                <Message
                  className={styles.message_item}
                  text={item.message}
                  author={item.author!}
                  time={item.created_at}
                  key={item.id}
                />
              ))}
          </div>
          <div className={styles.sending_messagesList}>
            <Sending ref={sendMessageRef} onKeyDown={sentMessage} />
          </div>
        </div>
      </div>
    );
  } else if (isLaptop) {
    return <div className={styles.talk_unselect}>Выберите чат</div>;
  }
};

export default Talk;


###### frontend\src\_pages\create_group\ui\create_group.module.scss
.create_group {
    background-color: var(--primary-foreground);
    width: 100%;
    height: 100%;
    border-radius: 15px 0 0 15px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.input_description {
    height: 175px !important;
}

.group_form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}


###### frontend\src\_pages\create_group\ui\create_group.tsx
"use client";
import { HTMLAttributes } from "react";

import styles from "./create_group.module.scss";
import Form from "@/shared/ui/form_page";
import Container from "@/shared/ui/container";
import InputText from "@/shared/ui/inputs/input_text";
import Button from "@/shared/ui/button";
import Textarea from "@/shared/ui/inputs/textarea";
import { useApiGroup } from "@/entities/group/model";
import { useRouter } from "next/navigation";
import FormPage from "@/shared/ui/form_page";

export interface CreateGroupProps extends HTMLAttributes<HTMLDivElement> {}

export const CreateGroup = ({}: CreateGroupProps) => {
  const router = useRouter();

  const { mutate } = useApiGroup.post();

  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const title = formData.get("title") as string;
    const description = formData.get("description") as string;

    if (!title || !description) return;

    mutate({
      requestBody: {
        title: title,
        description: description,
      },
    });

    router.push("/communication");
  };

  return (
    <FormPage title="Создание группы">
      <form onSubmit={onSubmit} className={styles.group_form}>
        <InputText
          type="text"
          placeholder="Моя группа"
          name="title"
          labelText="Название"
        />
        <Textarea
          placeholder="Расскажите о вашей группе"
          name="description"
          labelText="Описание"
          classNameInput={styles.input_description}
        />
        <Button type="submit">Создать</Button>
      </form>
    </FormPage>
  );
};

export default CreateGroup;


###### frontend\src\_pages\create_group\ui\index.ts
import CreateGroup from './create_group';

export default CreateGroup;
export type { CreateGroupProps } from './create_group';

###### frontend\src\_pages\group_settings\ui\group_settings.module.scss
.group_settings {
  background-color: var(--primary-foreground);
  width: 100%;
  min-height: 100%;
  border-radius: 15px 15px 0 0;
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 40px;
  padding-top: 40px;
}

.settings {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

.back {
  cursor: pointer;
}

.container {
  overflow-y: auto !important;
}


###### frontend\src\_pages\group_settings\ui\group_settings.tsx
"use client";
import { HTMLAttributes } from "react";

import styles from "./group_settings.module.scss";
import Container from "@/shared/ui/container";
import { useApiGroup } from "@/entities/group/model";
import ImageUploader from "@/shared/ui/image_uploader";
import { useAppSelector } from "@/shared/lib/hooks";
import { useRouter } from "next/navigation";
import { IconArrowBackUp } from "@tabler/icons-react";

export interface GroupSettingsProps extends HTMLAttributes<HTMLDivElement> {}

export const GroupSettings = ({}: GroupSettingsProps) => {
  const groupId = useAppSelector((state) => state.group.id);
  const router = useRouter();
  const uploadAvatar = useApiGroup.uploadAvatar();
  const uploadPanorama = useApiGroup.uploadPanorama();

  const uploadAvatarCallback = (file: File) => {
    if (!groupId) {
      alert("Попробуйте снова зайти в настройки группы");
      return;
    }

    uploadAvatar.mutate({
      groupId: groupId,
      formData: { image: file },
    });
  };

  const uploadPanoramaCallback = (file: File) => {
    if (!groupId) {
      alert("Попробуйте снова зайти в настройки группы");
      return;
    }

    uploadPanorama.mutate({
      groupId: groupId,
      formData: { image: file },
    });
  };

  return (
    <Container className={styles.container}>
      <div className={styles.group_settings}>
        <div className={styles.back} onClick={router.back}>
          <IconArrowBackUp width={45} height={45} />
        </div>
        <div className={styles.settings}>
          <h1>Настройки группы</h1>
          <ImageUploader
            title="Загрузить аватар группы"
            uploadCallback={uploadAvatarCallback}
          />
          <ImageUploader
            title="Загрузить панораму группы"
            uploadCallback={uploadPanoramaCallback}
          />
        </div>
      </div>
    </Container>
  );
};

export default GroupSettings;


###### frontend\src\_pages\group_settings\ui\index.ts
import GroupSettings from './group_settings';

export default GroupSettings;
export type { GroupSettingsProps } from './group_settings';

###### frontend\src\_pages\join_group\ui\index.ts
import JoinGroup from './join_group';

export default JoinGroup;
export type { JoinGroupProps } from './join_group';

###### frontend\src\_pages\join_group\ui\join_group.module.scss
.join_group {
    
}

###### frontend\src\_pages\join_group\ui\join_group.tsx
"use client";
import { HTMLAttributes, use, useEffect } from "react";

import styles from "./join_group.module.scss";
import { useApiGroup } from "@/entities/group/model";
import { useRouter } from "next/navigation";

export interface JoinGroupProps extends HTMLAttributes<HTMLDivElement> {
  params: Promise<{ id: string }>;
}

// component must be in /[id]
export const JoinGroup = ({ params }: JoinGroupProps) => {
  const { id } = use(params);
  const { mutate } = useApiGroup.postInviteToken();
  const router = useRouter();

  useEffect(() => {
    mutate({ requestBody: id });
    router.push("/communication");
  }, []);

  return <div className={styles["join_group"]}>JoinGroup Component</div>;
};

export default JoinGroup;


###### frontend\src\_pages\login\ui\index.ts
export { default } from './login';
export type { LoginProps } from './login';


###### frontend\src\_pages\login\ui\login.module.scss
.login {
    background-color: var(--primary-foreground);
    width: 100%;
    height: 100%;
    border-radius: 15px 0 0 15px;
    display: flex;
    align-items: center;
    justify-content: center;
}


###### frontend\src\_pages\login\ui\login.tsx
"use client";
import { HTMLAttributes } from "react";

import LoginForm from "@/features/login/ui";
import FormPage from "@/shared/ui/form_page";

export interface LoginProps extends HTMLAttributes<HTMLDivElement> {}

export const Login = ({}: LoginProps) => {
  return (
    <FormPage title="Вход">
      <LoginForm />
    </FormPage>
  );
};

export default Login;


###### frontend\src\_pages\registration\ui\index.ts
import Registration from './registration';

export default Registration;
export type { RegistrationProps } from './registration';

###### frontend\src\_pages\registration\ui\registration.module.scss
.registration {
    
}

###### frontend\src\_pages\registration\ui\registration.tsx
import { HTMLAttributes } from "react";

import styles from "./registration.module.scss";
import RegistrationForm from "@/features/registration/ui";
import FormPage from "@/shared/ui/form_page";

export interface RegistrationProps extends HTMLAttributes<HTMLDivElement> {}

export const Registration = ({}: RegistrationProps) => {
  return (
    <FormPage title="Регистрация">
      <RegistrationForm />
    </FormPage>
  );
};

export default Registration;


